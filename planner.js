const curriculumModel = {
    Alpha: {
        name: 'Percorso Alpha',
        description: 'Livelli A1 e A2 del Quadro Comune Europeo di Riferimento per le lingue.',
        levels: [
            {
                id: 'alpha-a1',
                name: 'Livello A1 (Quadro Comune Europeo di Riferimento per le lingue)',
                sections: [
                    {
                        id: 'alpha-a1-ascolto',
                        title: 'Ascolto',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-ascolto-1',
                                code: '1',
                                label: 'Comprendere istruzioni che vengono impartite purché si parli lentamente e chiaramente.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-ascolto-2',
                                code: '2',
                                label: 'Comprendere un discorso pronunciato molto lentamente e articolato con grande precisione, che contenga lunghe pause per permettere di assimilarne il senso.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a1-lettura',
                        title: 'Lettura',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-lettura-3',
                                code: '3',
                                label: 'Comprendere testi molto brevi e semplici, cogliendo nomi conosciuti, parole ed espressioni familiari ed eventualmente rileggendo.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a1-interazione',
                        title: 'Interazione orale e scritta',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-interazione-4',
                                code: '4',
                                label: 'Porre e rispondere a semplici domande relative a se stessi, alle azioni quotidiane e ai luoghi dove si vive.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-interazione-5',
                                code: '5',
                                label: 'Utilizzare in uno scambio comunicativo numeri, quantità, costi, orari.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-interazione-6',
                                code: '6',
                                label: 'Compilare un semplice modulo con i propri dati anagrafici.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a1-produzione-orale',
                        title: 'Produzione orale',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-produzione-orale-7',
                                code: '7',
                                label: 'Descrivere se stessi, le azioni quotidiane e i luoghi dove si vive.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-produzione-orale-8',
                                code: '8',
                                label: 'Formulare espressioni semplici, prevalentemente isolate, su persone e luoghi.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a1-produzione-scritta',
                        title: 'Produzione scritta',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-produzione-scritta-9',
                                code: '9',
                                label: 'Scrivere i propri dati anagrafici, numeri e date.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-produzione-scritta-10',
                                code: '10',
                                label: 'Scrivere semplici espressioni e frasi isolate.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    }
                ]
            },
            {
                id: 'alpha-a2',
                name: 'Livello A2 (Quadro Comune Europeo di Riferimento per le lingue)',
                sections: [
                    {
                        id: 'alpha-a2-ascolto',
                        title: 'Ascolto',
                        totalHours: 15,
                        subtopics: [
                            {
                                id: 'alpha-a2-ascolto-1',
                                code: '1',
                                label: 'Comprendere quanto basta per soddisfare bisogni di tipo concreto, purché si parli lentamente e chiaramente.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-ascolto-2',
                                code: '2',
                                label: 'Comprendere espressioni riferite ad aree di priorità immediata quali la persona, la famiglia, gli acquisti, la geografia locale e il lavoro, purché si parli lentamente e chiaramente.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a2-lettura',
                        title: 'Lettura',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a2-lettura-3',
                                code: '3',
                                label: 'Comprendere testi brevi e semplici di contenuto familiare e di tipo concreto, formulati nel linguaggio che ricorre frequentemente nella vita di tutti i giorni e/o sul lavoro.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a2-interazione',
                        title: 'Interazione orale e scritta',
                        totalHours: 15,
                        subtopics: [
                            {
                                id: 'alpha-a2-interazione-4',
                                code: '4',
                                label: 'Far fronte a scambi di routine, ponendo e rispondendo a domande semplici.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-interazione-5',
                                code: '5',
                                label: 'Scambiare informazioni su argomenti e attività consuete riferite alla famiglia, all’ambiente, al lavoro e al tempo libero.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-interazione-6',
                                code: '6',
                                label: 'Scrivere brevi e semplici appunti, relativi a bisogni immediati, usando formule convenzionali.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a2-produzione-orale',
                        title: 'Produzione orale',
                        totalHours: 15,
                        subtopics: [
                            {
                                id: 'alpha-a2-produzione-orale-7',
                                code: '7',
                                label: 'Descrivere o presentare in modo semplice persone, condizioni di vita o di lavoro, compiti quotidiani.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-produzione-orale-8',
                                code: '8',
                                label: 'Usare semplici espressioni e frasi legate insieme per indicare le proprie preferenze.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a2-produzione-scritta',
                        title: 'Produzione scritta',
                        totalHours: 15,
                        subtopics: [
                            {
                                id: 'alpha-a2-produzione-scritta-9',
                                code: '9',
                                label: 'Scrivere una serie di elementari espressioni e frasi legate da semplici connettivi quali “e”, “ma”, “perché” relativi a contesti di vita sociali, culturali e lavorativi.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-produzione-scritta-10',
                                code: '10',
                                label: 'Scrivere una semplice lettera personale su argomenti e attività consuete riferite alla famiglia, all’ambiente, al lavoro e al tempo libero.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    }
                ]
            }
        ]
    },
    Primo: {
        name: 'Percorso Primo',
        description: 'Contenuti in fase di definizione.',
        levels: []
    },
    Secondo: {
        name: 'Percorso Secondo',
        description: 'Contenuti in fase di definizione.',
        levels: []
    }
};

class CurriculumPlanner {
    constructor(model) {
        this.data = JSON.parse(JSON.stringify(model));
        this.state = {
            selectedLevel: null,
            toastTimer: null
        };
        this.distanceCapRatio = 0.2;

        this.elements = {
            detailsPanel: document.getElementById('details-panel'),
            summaryPanel: document.getElementById('summary-panel'),
            summaryContent: document.getElementById('summary-content'),
            toast: document.getElementById('toast'),
            levelButtons: Array.from(document.querySelectorAll('.level-button')),
            printButton: document.getElementById('print-plan')
        };

        this.bindEvents();
        this.render();
    }

    bindEvents() {
        this.elements.levelButtons.forEach((button) => {
            button.addEventListener('click', () => this.setLevel(button.dataset.level));
        });

        if (this.elements.printButton) {
            this.elements.printButton.addEventListener('click', () => this.exportToPdf());
        }
    }

    setLevel(levelKey) {
        if (this.state.selectedLevel === levelKey) {
            return;
        }

        this.state.selectedLevel = levelKey;

        this.elements.levelButtons.forEach((button) => {
            const isActive = button.dataset.level === levelKey;
            button.classList.toggle('active', isActive);
            button.setAttribute('aria-pressed', String(isActive));
        });

        this.renderDetails();
        this.renderSummary();
        this.scrollToDetails();
    }

    render() {
        this.renderDetails();
        this.renderSummary();
    }

    renderDetails() {
        const container = this.elements.detailsPanel;
        const levelKey = this.state.selectedLevel;

        if (!levelKey) {
            container.innerHTML = `
                <div class="empty-state">
                    <h2>Seleziona un percorso per iniziare</h2>
                    <p>Scegli <strong>Alpha</strong>, <strong>Primo</strong> o <strong>Secondo</strong> per visualizzare la struttura delle attività.</p>
                </div>
            `;
            if (this.elements.printButton) {
                this.elements.printButton.disabled = true;
                this.elements.printButton.setAttribute('aria-disabled', 'true');
            }
            return;
        }

        const levelData = this.data[levelKey];

        if (!levelData || !levelData.levels || levelData.levels.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <h2>${levelData ? levelData.name : 'Percorso non disponibile'}</h2>
                    <p>${levelData ? levelData.description : 'Contenuti non ancora configurati.'}</p>
                </div>
            `;
            if (this.elements.printButton) {
                this.elements.printButton.disabled = true;
                this.elements.printButton.setAttribute('aria-disabled', 'true');
            }
            return;
        }

        const markup = levelData.levels.map((level) => this.renderLevel(level)).join('');
        container.innerHTML = markup;
        this.attachInteractions();

        if (this.elements.printButton) {
            this.elements.printButton.disabled = false;
            this.elements.printButton.setAttribute('aria-disabled', 'false');
        }
    }

    renderLevel(level) {
        const totals = this.computeLevelTotals(level);

        return `
            <article class="level-block" data-level-id="${level.id}">
                <div class="level-block__header">
                    <div class="level-block__meta">
                        <h2 class="level-block__title">${level.name}</h2>
                        <p class="level-description">Totale ore previste: <strong>${totals.total}</strong></p>
                    </div>
                    <div class="capsule">${totals.assigned}/${totals.total} ore assegnate</div>
                </div>
                <div class="section-grid">
                    ${level.sections.map((section) => this.renderSection(section)).join('')}
                </div>
            </article>
        `;
    }

    renderSection(section) {
        const allocated = this.sectionAllocated(section);
        const remaining = this.sectionRemaining(section);
        const completion = section.totalHours > 0 ? Math.min(100, Math.round((allocated / section.totalHours) * 100)) : 0;
        const statusText = remaining === 0 && section.totalHours > 0
            ? 'Distribuzione completata'
            : `Ore da assegnare: ${remaining}`;
        const cardClasses = ['section-card'];
        const distanceCap = this.sectionDistanceCap(section);
        const distanceAllocated = this.sectionDistanceAllocated(section);
        const distanceRemaining = Math.max(0, distanceCap - distanceAllocated);
        const distanceStatus = distanceCap === 0
            ? 'Nessuna attività a distanza consentita per questa sezione.'
            : distanceRemaining === 0
                ? 'Limite ore distanza raggiunto.'
                : `Ore a distanza disponibili: ${distanceRemaining}`;
        const distanceClasses = ['section-distance'];
        if (distanceRemaining === 0 && distanceCap > 0) {
            distanceClasses.push('--limit');
        }

        if (remaining === 0 && section.totalHours > 0) {
            cardClasses.push('complete');
        }

        return `
            <div class="${cardClasses.join(' ')}" data-section-id="${section.id}">
                <div class="section-card__top">
                    <div class="section-card__meta">
                        <h3 class="section-title">${section.title}</h3>
                        <span class="capsule">${section.totalHours} ore totali</span>
                    </div>
                    <div class="section-feedback${remaining === 0 ? '' : ' --warning'}">
                        <span class="section-feedback__counter">Assegnate <strong>${allocated}</strong> ore</span>
                        <span class="section-feedback__status">${statusText}</span>
                    </div>
                </div>
                <div class="progress">
                    <div class="progress__bar" style="width: ${completion}%;"></div>
                </div>
                <div class="${distanceClasses.join(' ')}">
                    <span class="section-distance__counter">Ore distanza: <strong>${distanceAllocated}</strong>${distanceCap > 0 ? ` / ${distanceCap}` : ''}</span>
                    <span class="section-distance__status">${distanceStatus}</span>
                </div>
                <div class="subtopics">
                    ${section.subtopics.map((subtopic) => this.renderSubtopic(section, subtopic)).join('')}
                </div>
            </div>
        `;
    }

    renderSubtopic(section, subtopic) {
        const percent = section.totalHours > 0 ? Math.round((subtopic.hours / section.totalHours) * 100) : 0;
        const sliderBackground = this.buildSliderGradient(percent);
        const presenceHours = Math.max(0, subtopic.hours - (subtopic.distanceHours || 0));
        const sectionCap = this.sectionDistanceCap(section);
        const distanceAllocated = this.sectionDistanceAllocated(section);
        const currentDistance = subtopic.distanceHours || 0;
        const otherDistance = distanceAllocated - currentDistance;
        const remainingForSection = Math.max(0, sectionCap - otherDistance);
        const maxAllowedForThis = Math.min(subtopic.hours, currentDistance + remainingForSection);
        const sliderMax = sectionCap;
        const distanceDisabled = sectionCap === 0;
        const effectiveDistance = subtopic.distanceHours || 0;
        const distancePercent = sectionCap > 0 ? Math.min(100, Math.round((effectiveDistance / sectionCap) * 100)) : 0;
        const distanceSliderBg = this.buildDistanceSliderGradient(distancePercent);

        return `
            <div class="subtopic" data-section-id="${section.id}" data-subtopic-id="${subtopic.id}">
                <div class="subtopic-header">
                    <span class="subtopic-code">${subtopic.code ? subtopic.code + '.' : ''}</span>
                    <span class="subtopic-title">${subtopic.label}</span>
                    <div class="subtopic-badges">
                        <span class="subtopic-hours">${subtopic.hours} h totali</span>
                        <span class="subtopic-distance-tag">${subtopic.distanceHours} h distanza</span>
                    </div>
                </div>
                <div class="subtopic-distribution">
                    <span>Presenza: <strong>${presenceHours}</strong> h</span>
                    <span>Distanza: <strong>${subtopic.distanceHours}</strong> h</span>
                </div>
                <div class="subtopic-controls">
                    <input
                        type="range"
                        class="subtopic-slider"
                        min="0"
                        max="${section.totalHours}"
                        value="${subtopic.hours}"
                        data-section-id="${section.id}"
                        data-subtopic-id="${subtopic.id}"
                        aria-label="Ore assegnate per ${subtopic.label}"
                        style="background-image: ${sliderBackground};"
                    />
                    <div class="subtopic-inputs">
                        <div class="input-group">
                            <label for="input-${subtopic.id}">Ore totali</label>
                            <input
                                id="input-${subtopic.id}"
                                type="number"
                                class="subtopic-input"
                                min="0"
                                max="${section.totalHours}"
                                step="1"
                                value="${subtopic.hours}"
                                data-section-id="${section.id}"
                                data-subtopic-id="${subtopic.id}"
                            />
                        </div>
                        <div class="input-group distance-group" data-cap="${sectionCap}" data-section-id="${section.id}">
                            <div class="distance-cap-hint">
                                Cap sezione: <strong>${sectionCap}</strong> h
                                <span class="distance-cap-separator" aria-hidden="true">•</span>
                                Residuo sezione: <strong>${Math.max(0, sectionCap - distanceAllocated)}</strong> h
                                <span class="distance-cap-separator" aria-hidden="true">•</span>
                                Disponibile voce: <strong>${maxAllowedForThis}</strong> h
                            </div>
                            <label for="distance-${subtopic.id}">Ore a distanza (<span class="distance-value">${subtopic.distanceHours}</span> h)</label>
                            <input
                                id="distance-${subtopic.id}"
                                type="range"
                                class="subtopic-distance-slider"
                                min="0"
                                max="${sliderMax}"
                                step="1"
                                value="${subtopic.distanceHours}"
                                data-section-id="${section.id}"
                                data-subtopic-id="${subtopic.id}"
                                data-cap="${sectionCap}"
                                style="background: ${distanceSliderBg};"
                                aria-valuemin="0"
                                aria-valuemax="${sliderMax}"
                                aria-valuenow="${subtopic.distanceHours}"
                                aria-label="Ore a distanza per ${subtopic.label} (cap sezione ${sectionCap}h, residuo ${Math.max(0, sectionCap - distanceAllocated)}h)"
                                ${distanceDisabled ? 'disabled' : ''}
                            />
                            <div class="distance-input-wrapper">
                                <label class="sr-only" for="distance-input-${subtopic.id}">Inserisci ore a distanza (valore numerico)</label>
                                <input
                                    id="distance-input-${subtopic.id}"
                                    type="number"
                                    class="subtopic-distance-input"
                                    min="0"
                                    max="${sliderMax}"
                                    step="1"
                                    value="${subtopic.distanceHours}"
                                    data-section-id="${section.id}"
                                    data-subtopic-id="${subtopic.id}"
                                    data-cap="${sectionCap}"
                                    aria-label="Ore a distanza per ${subtopic.label} (input numerico)"
                                    ${distanceDisabled ? 'disabled' : ''}
                                />
                                <span class="distance-input-max">/ ${sectionCap} h</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    attachInteractions() {
        const sliders = this.elements.detailsPanel.querySelectorAll('.subtopic-slider');
        const inputs = this.elements.detailsPanel.querySelectorAll('.subtopic-input');
        const distanceSliders = this.elements.detailsPanel.querySelectorAll('.subtopic-distance-slider');
        const distanceInputs = this.elements.detailsPanel.querySelectorAll('.subtopic-distance-input');

        sliders.forEach((slider) => {
            slider.addEventListener('input', this.handleAllocationUpdate);
        });

        inputs.forEach((input) => {
            input.addEventListener('change', this.handleAllocationUpdate);
            input.addEventListener('input', (event) => {
                if (event.target.value === '') {
                    return;
                }
                this.handleAllocationUpdate(event);
            });
        });

        distanceSliders.forEach((slider) => {
            if (slider.disabled) {
                return;
            }
            slider.addEventListener('input', this.handleDistanceUpdate);
            slider.addEventListener('change', this.handleDistanceUpdate);
        });

        distanceInputs.forEach((input) => {
            if (input.disabled) {
                return;
            }
            input.addEventListener('change', this.handleDistanceUpdate);
            input.addEventListener('input', (event) => {
                if (event.target.value === '') {
                    return;
                }
                this.handleDistanceUpdate(event);
            });
        });
    }

    handleAllocationUpdate = (event) => {
        const { sectionId, subtopicId } = event.target.dataset;
        if (!sectionId || !subtopicId) {
            return;
        }

        const parsedValue = Number.parseInt(event.target.value, 10);
        const newValue = Number.isNaN(parsedValue) ? 0 : parsedValue;

        this.updateAllocation(sectionId, subtopicId, newValue);
    };

    handleDistanceUpdate = (event) => {
        const { sectionId, subtopicId } = event.target.dataset;
        if (!sectionId || !subtopicId) {
            return;
        }

        const parsedValue = Number.parseInt(event.target.value, 10);
        const newValue = Number.isNaN(parsedValue) ? 0 : parsedValue;

        this.updateDistanceAllocation(sectionId, subtopicId, newValue);
    };

    updateAllocation(sectionId, subtopicId, proposedValue) {
        const context = this.findSection(sectionId);
        if (!context) {
            return;
        }

        const { section } = context;
        const sanitized = Math.max(0, Math.round(proposedValue));
        const otherSum = section.subtopics.reduce((sum, sub) => sum + (sub.id === subtopicId ? 0 : sub.hours), 0);
        const maxAllowed = Math.max(0, section.totalHours - otherSum);
        const finalValue = Math.min(sanitized, maxAllowed);
        const subtopic = section.subtopics.find((sub) => sub.id === subtopicId);

        if (!subtopic) {
            return;
        }

        subtopic.hours = finalValue;

        const sectionCap = this.sectionDistanceCap(section);
        const totalDistance = this.sectionDistanceAllocated(section);
        if (totalDistance > sectionCap) {
            const otherDistance = totalDistance - (subtopic.distanceHours || 0);
            const allowedForThis = Math.max(0, sectionCap - otherDistance);
            if (subtopic.distanceHours > allowedForThis) {
                subtopic.distanceHours = allowedForThis;
                this.showToast('Ore distanza ridotte per rispettare il 20% della sezione.');
            }
        }

        if (sanitized > maxAllowed) {
            const remaining = Math.max(0, maxAllowed);
            const message = remaining === 0
                ? 'Tutte le ore per questa voce sono già distribuite.'
                : `Puoi assegnare al massimo ${remaining} ore a questa sotto-voce.`;
            this.showToast(message);
        }

        this.refreshSection(section.id);
        this.renderSummary();
    }

    updateDistanceAllocation(sectionId, subtopicId, proposedValue) {
        const context = this.findSection(sectionId);
        if (!context) {
            return;
        }

        const { section } = context;
        const subtopic = section.subtopics.find((sub) => sub.id === subtopicId);

        if (!subtopic) {
            return;
        }

        const sanitized = Math.max(0, Math.round(proposedValue));
        const sectionCap = this.sectionDistanceCap(section);
        const otherDistance = section.subtopics.reduce((sum, s) => sum + (s.id === subtopic.id ? 0 : (s.distanceHours || 0)), 0);
        const remainingForSection = Math.max(0, sectionCap - otherDistance);
        const maxAllowedForThis = Math.min(subtopic.hours, (subtopic.distanceHours || 0) + remainingForSection);
        const finalValue = Math.min(sanitized, maxAllowedForThis);

        if (sanitized > subtopic.hours) {
            this.showToast('Le ore a distanza non possono superare le ore totali della voce.');
        } else if (sanitized > maxAllowedForThis) {
            this.showToast('Limite distanza di sezione raggiunto.');
        }

        subtopic.distanceHours = finalValue;

        this.refreshSection(section.id);
        this.renderSummary();

        const sectionElement = this.elements.detailsPanel.querySelector(`[data-section-id="${section.id}"]`);
        if (!sectionElement) {
            return;
        }

        const subtopicElement = sectionElement.querySelector(`.subtopic[data-subtopic-id="${subtopic.id}"]`);
        if (!subtopicElement) {
            return;
        }

        const slider = subtopicElement.querySelector('.subtopic-distance-slider');
        if (slider) {
            const updatedSectionCap = this.sectionDistanceCap(section);
            const totalDistance = this.sectionDistanceAllocated(section);
            const otherAllocated = totalDistance - subtopic.distanceHours;
            const remainingForSection = Math.max(0, updatedSectionCap - otherAllocated);
            const maxAllowedForThis = Math.min(subtopic.hours, subtopic.distanceHours + remainingForSection);
            slider.max = updatedSectionCap;
            slider.value = subtopic.distanceHours;
            const percent = updatedSectionCap > 0 ? Math.min(100, Math.round((subtopic.distanceHours / updatedSectionCap) * 100)) : 0;
            slider.style.background = this.buildDistanceSliderGradient(percent);
            slider.setAttribute('aria-valuemax', updatedSectionCap);
            slider.setAttribute('aria-valuenow', String(subtopic.distanceHours));

            const numberInput = subtopicElement.querySelector('.subtopic-distance-input');
            if (numberInput) {
                numberInput.max = updatedSectionCap;
                numberInput.disabled = updatedSectionCap === 0;
                numberInput.value = subtopic.distanceHours;
            }

            const capHint = subtopicElement.querySelector('.distance-cap-hint');
            if (capHint) {
                capHint.innerHTML = `
                    Cap sezione: <strong>${updatedSectionCap}</strong> h
                    <span class="distance-cap-separator" aria-hidden="true">•</span>
                    Residuo sezione: <strong>${Math.max(0, updatedSectionCap - this.sectionDistanceAllocated(section))}</strong> h
                    <span class="distance-cap-separator" aria-hidden="true">•</span>
                    Disponibile voce: <strong>${maxAllowedForThis}</strong> h
                `;
            }
        }

        const distanceValueLabel = subtopicElement.querySelector('.distance-value');
        if (distanceValueLabel) {
            distanceValueLabel.textContent = subtopic.distanceHours;
        }
    }

    refreshSection(sectionId) {
        const sectionElement = this.elements.detailsPanel.querySelector(`[data-section-id="${sectionId}"]`);
        const context = this.findSection(sectionId);

        if (!sectionElement || !context) {
            return;
        }

        const { section } = context;
        const allocated = this.sectionAllocated(section);
        const remaining = this.sectionRemaining(section);
        const completion = section.totalHours > 0 ? Math.min(100, Math.round((allocated / section.totalHours) * 100)) : 0;
        const distanceAllocated = this.sectionDistanceAllocated(section);
        const distanceCap = this.sectionDistanceCap(section);
        const distanceRemaining = Math.max(0, distanceCap - distanceAllocated);
        const distanceStatus = distanceCap === 0
            ? 'Nessuna distanza prevista.'
            : `Residuo distanza sezione: ${distanceRemaining} h`;

        const progressBar = sectionElement.querySelector('.progress__bar');
        if (progressBar) {
            progressBar.style.width = `${completion}%`;
        }

        const feedback = sectionElement.querySelector('.section-feedback');
        if (feedback) {
            feedback.classList.toggle('--warning', !(remaining === 0 && section.totalHours > 0));
            const counter = feedback.querySelector('.section-feedback__counter');
            const status = feedback.querySelector('.section-feedback__status');
            if (counter) {
                counter.innerHTML = `Assegnate <strong>${allocated}</strong> ore`;
            }
            if (status) {
                status.textContent = remaining === 0 && section.totalHours > 0
                    ? 'Distribuzione completata'
                    : `Ore da assegnare: ${remaining}`;
            }
        }

        sectionElement.classList.toggle('complete', remaining === 0 && section.totalHours > 0);

        const distanceCounter = sectionElement.querySelector('.section-distance__counter');
        if (distanceCounter) {
            distanceCounter.innerHTML = distanceCap > 0
                ? `Distanza (somma voci): <strong>${distanceAllocated}</strong> / ${distanceCap}`
                : `Distanza (somma voci): <strong>${distanceAllocated}</strong>`;
        }
        const distanceState = sectionElement.querySelector('.section-distance__status');
        if (distanceState) {
            distanceState.textContent = distanceStatus;
        }

        section.subtopics.forEach((subtopic) => {
            const subtopicElement = sectionElement.querySelector(`.subtopic[data-subtopic-id="${subtopic.id}"]`);
            if (!subtopicElement) {
                return;
            }

            const hoursLabel = subtopicElement.querySelector('.subtopic-hours');
            if (hoursLabel) {
                hoursLabel.textContent = `${subtopic.hours} h totali`;
            }

            const distanceTag = subtopicElement.querySelector('.subtopic-distance-tag');
            if (distanceTag) {
                distanceTag.textContent = `${subtopic.distanceHours} h distanza`;
            }

            const slider = subtopicElement.querySelector('.subtopic-slider');
            if (slider) {
                slider.value = subtopic.hours;
                const percent = section.totalHours > 0 ? Math.round((subtopic.hours / section.totalHours) * 100) : 0;
                slider.style.backgroundImage = this.buildSliderGradient(percent);
            }

            const input = subtopicElement.querySelector('.subtopic-input');
            if (input && document.activeElement !== input) {
                input.value = subtopic.hours;
            }

            const presenceHours = Math.max(0, subtopic.hours - (subtopic.distanceHours || 0));
            const distributionLabels = subtopicElement.querySelectorAll('.subtopic-distribution strong');
            if (distributionLabels[0]) {
                distributionLabels[0].textContent = presenceHours;
            }
            if (distributionLabels[1]) {
                distributionLabels[1].textContent = subtopic.distanceHours;
            }

            const distanceSlider = subtopicElement.querySelector('.subtopic-distance-slider');
            const distanceInput = subtopicElement.querySelector('.subtopic-distance-input');
            if (distanceSlider) {
                const updatedSectionCap = this.sectionDistanceCap(section);
                const totalDistance = this.sectionDistanceAllocated(section);
                const currentDistance = subtopic.distanceHours || 0;
                const otherDistance = totalDistance - currentDistance;
                const remainingForSection = Math.max(0, updatedSectionCap - otherDistance);
                const maxAllowedForThis = Math.min(subtopic.hours, currentDistance + remainingForSection);

                distanceSlider.max = updatedSectionCap;
                distanceSlider.disabled = updatedSectionCap === 0;
                if (document.activeElement !== distanceSlider) {
                    distanceSlider.value = subtopic.distanceHours;
                }
                const percent = updatedSectionCap > 0 ? Math.min(100, Math.round((subtopic.distanceHours / updatedSectionCap) * 100)) : 0;
                distanceSlider.style.background = this.buildDistanceSliderGradient(percent);
                distanceSlider.setAttribute('aria-valuemax', updatedSectionCap);
                distanceSlider.setAttribute('aria-valuenow', String(subtopic.distanceHours));

                const distanceValueLabel = subtopicElement.querySelector('.distance-value');
                if (distanceValueLabel) {
                    distanceValueLabel.textContent = subtopic.distanceHours;
                }

                const capHint = subtopicElement.querySelector('.distance-cap-hint');
                if (capHint) {
                    capHint.innerHTML = `
                        Cap sezione: <strong>${updatedSectionCap}</strong> h
                        <span class="distance-cap-separator" aria-hidden="true">•</span>
                        Residuo sezione: <strong>${Math.max(0, updatedSectionCap - this.sectionDistanceAllocated(section))}</strong> h
                        <span class="distance-cap-separator" aria-hidden="true">•</span>
                        Disponibile voce: <strong>${maxAllowedForThis}</strong> h
                    `;
                }
            }

            if (distanceInput) {
                const updatedSectionCap = this.sectionDistanceCap(section);
                distanceInput.max = updatedSectionCap;
                distanceInput.disabled = updatedSectionCap === 0;
                if (document.activeElement !== distanceInput) {
                    distanceInput.value = subtopic.distanceHours;
                }
            }
        });
    }

    buildSliderGradient(percent) {
        return `linear-gradient(90deg, rgba(99, 102, 241, 0.65) 0%, rgba(99, 102, 241, 0.65) ${percent}%, rgba(148, 163, 184, 0.35) ${percent}%, rgba(148, 163, 184, 0.35) 100%)`;
    }

    buildDistanceSliderGradient(percent) {
        return `linear-gradient(90deg, rgba(14,165,233,0.9) 0%, rgba(14,165,233,0.9) ${percent}%, rgba(148,163,184,0.35) ${percent}%, rgba(148,163,184,0.35) 100%)`;
    }

    findSection(sectionId) {
        const levelKey = this.state.selectedLevel;
        if (!levelKey) {
            return null;
        }

        const levelData = this.data[levelKey];
        if (!levelData || !levelData.levels) {
            return null;
        }

        for (const level of levelData.levels) {
            const section = level.sections.find((item) => item.id === sectionId);
            if (section) {
                return { level, section };
            }
        }
        return null;
    }

    sectionAllocated(section) {
        return section.subtopics.reduce((sum, sub) => sum + sub.hours, 0);
    }

    sectionRemaining(section) {
        return Math.max(0, section.totalHours - this.sectionAllocated(section));
    }

    sectionDistanceAllocated(section) {
        return section.subtopics.reduce((sum, sub) => sum + (sub.distanceHours || 0), 0);
    }

    sectionDistanceCap(section) {
        return Math.floor((section.totalHours || 0) * this.distanceCapRatio);
    }

    sectionDistanceRemaining(section) {
        return Math.max(0, this.sectionDistanceCap(section) - this.sectionDistanceAllocated(section));
    }

    computeLevelTotals(level) {
        return level.sections.reduce((acc, section) => {
            const allocated = this.sectionAllocated(section);
            const remaining = this.sectionRemaining(section);
            const distanceAllocated = this.sectionDistanceAllocated(section);
            const distanceCap = this.sectionDistanceCap(section);
            acc.total += section.totalHours;
            acc.assigned += allocated;
            acc.remaining += remaining;
            acc.distanceAssigned += distanceAllocated;
            acc.distanceCap += distanceCap;
            if (remaining === 0 && section.totalHours > 0) {
                acc.completedSections += 1;
            }
            acc.totalSections += 1;
            return acc;
        }, { total: 0, assigned: 0, remaining: 0, completedSections: 0, totalSections: 0, distanceAssigned: 0, distanceCap: 0 });
    }

    renderSummary() {
        const levelKey = this.state.selectedLevel;
        const { summaryPanel, summaryContent } = this.elements;

        if (!levelKey) {
            summaryPanel.classList.add('hidden');
            return;
        }

        const levelData = this.data[levelKey];
        if (!levelData || !levelData.levels || levelData.levels.length === 0) {
            summaryPanel.classList.add('hidden');
            return;
        }

        const totals = {
            total: 0,
            assigned: 0,
            remaining: 0,
            completedSections: 0,
            totalSections: 0,
            distanceAssigned: 0,
            distanceCap: 0
        };

        const breakdown = levelData.levels.map((level) => {
            const stats = this.computeLevelTotals(level);
            totals.total += stats.total;
            totals.assigned += stats.assigned;
            totals.remaining += stats.remaining;
            totals.completedSections += stats.completedSections;
            totals.totalSections += stats.totalSections;
            totals.distanceAssigned += stats.distanceAssigned;
            totals.distanceCap += stats.distanceCap;
            return { level, stats };
        });

        const presenceHours = Math.max(0, totals.assigned - totals.distanceAssigned);

        const cards = [
            { label: 'Ore disponibili', value: `${totals.total} h` },
            { label: 'Ore assegnate', value: `${totals.assigned} h` },
            { label: 'Ore rimanenti', value: `${totals.remaining} h` },
            {
                label: 'Ore a distanza',
                value: totals.distanceCap > 0
                    ? `${totals.distanceAssigned}/${totals.distanceCap} h`
                    : `${totals.distanceAssigned} h`
            },
            { label: 'Ore in presenza', value: `${presenceHours} h` },
            { label: 'Sezioni complete', value: `${totals.completedSections}/${totals.totalSections}` }
        ];

        const breakdownCards = breakdown.map(({ level, stats }) => ({
            label: level.name,
            value: `${stats.assigned}/${stats.total} h`,
            meta: stats.distanceCap > 0
                ? `Distanza ${stats.distanceAssigned}/${stats.distanceCap} h`
                : 'Distanza non prevista'
        }));

        summaryContent.innerHTML = `
            ${[...cards, ...breakdownCards].map((item) => `
                <div class="summary-item">
                    <span>${item.label}</span>
                    <strong>${item.value}</strong>
                    ${item.meta ? `<small>${item.meta}</small>` : ''}
                </div>
            `).join('')}
        `;

        summaryPanel.classList.remove('hidden');

        let completionFlag = summaryPanel.querySelector('.completion-flag');
        if (!completionFlag) {
            completionFlag = document.createElement('div');
            completionFlag.className = 'completion-flag';
            summaryPanel.appendChild(completionFlag);
        }

        if (totals.total > 0 && totals.remaining === 0) {
            completionFlag.textContent = 'Hai distribuito tutte le ore disponibili! Ottimo lavoro.';
            completionFlag.classList.add('show');
        } else {
            completionFlag.textContent = 'Distribuisci tutte le ore per completare il percorso.';
            completionFlag.classList.remove('show');
        }
    }

    showToast(message) {
        const { toast } = this.elements;
        if (!toast) {
            return;
        }

        toast.textContent = message;
        toast.classList.add('show');
        toast.setAttribute('aria-hidden', 'false');

        if (this.state.toastTimer) {
            clearTimeout(this.state.toastTimer);
        }

        this.state.toastTimer = setTimeout(() => this.clearToast(), 2500);
    }

    clearToast() {
        const { toast } = this.elements;
        if (!toast) {
            return;
        }

        toast.classList.remove('show');
        toast.setAttribute('aria-hidden', 'true');
    }

    scrollToDetails() {
        if (!this.elements.detailsPanel) {
            return;
        }

        if (window.matchMedia('(max-width: 900px)').matches) {
            this.elements.detailsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    exportToPdf() {
        const levelKey = this.state.selectedLevel;
        if (!levelKey) {
            this.showToast('Seleziona prima un percorso da esportare.');
            return;
        }

        const levelData = this.data[levelKey];
        if (!levelData || !levelData.levels || levelData.levels.length === 0) {
            this.showToast('Nessun dato disponibile per l\'esportazione.');
            return;
        }

        const jsPdfNamespace = window.jspdf || window.jsPDF;
        const jsPDF = jsPdfNamespace ? jsPdfNamespace.jsPDF || jsPdfNamespace : null;
        if (!jsPDF) {
            this.showToast('Impossibile generare il PDF (jsPDF non disponibile).');
            return;
        }

        const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
        const marginX = 14;
        const marginY = 18;
        const lineHeight = 6;
        const pageHeight = doc.internal.pageSize.getHeight();
        const safeMarginBottom = 20;

        let currentY = marginY + lineHeight;

        const ensureSpace = (required = lineHeight) => {
            if (currentY + required >= pageHeight - safeMarginBottom) {
                doc.addPage();
                currentY = marginY;
            }
        };

        doc.setFont('helvetica', 'bold');
        doc.setFontSize(16);
        doc.text(levelData.name, marginX, marginY);

        if (levelData.description) {
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(11);
            const descLines = doc.splitTextToSize(levelData.description, 180);
            descLines.forEach((line) => {
                ensureSpace(lineHeight);
                doc.text(line, marginX, currentY);
                currentY += lineHeight;
            });
            currentY += lineHeight / 2;
        }

        levelData.levels.forEach((level, levelIndex) => {
            if (levelIndex > 0) {
                doc.addPage();
                currentY = marginY;
            }

            doc.setFont('helvetica', 'bold');
            doc.setFontSize(14);
            doc.text(level.name, marginX, currentY);
            currentY += lineHeight;

            const totals = this.computeLevelTotals(level);
            const presence = Math.max(0, totals.assigned - totals.distanceAssigned);
            const totalsText = `Ore totali ${totals.total} • Assegnate ${totals.assigned} • Presenza ${presence} • Distanza ${totals.distanceAssigned}${totals.distanceCap > 0 ? '/' + totals.distanceCap : ''}`;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10.5);
            const totalsLines = doc.splitTextToSize(totalsText, 180);
            totalsLines.forEach((line) => {
                ensureSpace(lineHeight);
                doc.text(line, marginX, currentY);
                currentY += lineHeight;
            });
            currentY += lineHeight / 3;

            level.sections.forEach((section, sectionIndex) => {
                if (sectionIndex > 0) {
                    currentY += lineHeight / 2;
                }

                ensureSpace(lineHeight * 2);
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(12);
                doc.text(section.title, marginX, currentY);
                currentY += lineHeight;

                const allocated = this.sectionAllocated(section);
                const distanceAllocated = this.sectionDistanceAllocated(section);
                const presenceHours = Math.max(0, allocated - distanceAllocated);
                const sectionCap = this.sectionDistanceCap(section);
                const sectionSummary = `Totale ${section.totalHours}h • Assegnate ${allocated}h • Presenza ${presenceHours}h • Distanza ${distanceAllocated}${sectionCap > 0 ? '/' + sectionCap : ''}h`;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(10);
                const summaryLines = doc.splitTextToSize(sectionSummary, 180);
                summaryLines.forEach((line) => {
                    ensureSpace(lineHeight);
                    doc.text(line, marginX, currentY);
                    currentY += lineHeight;
                });
                currentY += lineHeight / 3;

                const body = section.subtopics.map((subtopic) => {
                    const presence = Math.max(0, subtopic.hours - (subtopic.distanceHours || 0));
                    return [
                        subtopic.code || '',
                        doc.splitTextToSize(subtopic.label, 90),
                        this.formatHourLabel(subtopic.hours),
                        this.formatHourLabel(presence),
                        this.formatHourLabel(subtopic.distanceHours || 0)
                    ];
                });

                const tableOptions = {
                    startY: currentY,
                    head: [['Cod.', 'Voce', 'Ore tot.', 'Presenza', 'Distanza']],
                    body,
                    styles: {
                        font: 'helvetica',
                        fontSize: 9,
                        cellPadding: 2.6,
                        lineColor: [230, 233, 239],
                        lineWidth: 0.2
                    },
                    headStyles: {
                        fillColor: [99, 102, 241],
                        textColor: 255,
                        fontStyle: 'bold',
                        halign: 'center'
                    },
                    columnStyles: {
                        0: { halign: 'center', cellWidth: 16 },
                        1: { cellWidth: 90 },
                        2: { halign: 'center', cellWidth: 18 },
                        3: { halign: 'center', cellWidth: 20 },
                        4: { halign: 'center', cellWidth: 24 }
                    },
                    alternateRowStyles: {
                        fillColor: [248, 250, 252]
                    },
                    margin: { left: marginX, right: marginX },
                    didDrawPage: (data) => {
                        currentY = data.cursor.y + lineHeight;
                    }
                };

                if (typeof doc.autoTable === 'function') {
                    doc.autoTable(tableOptions);
                    currentY = doc.lastAutoTable ? doc.lastAutoTable.finalY + lineHeight : currentY + body.length * lineHeight;
                } else {
                    body.forEach((row) => {
                        ensureSpace(lineHeight * 2);
                        const [code, labelLines, total, presenceValue, distanceValue] = row;
                        const flattenedLabel = Array.isArray(labelLines) ? labelLines : [labelLines];
                        doc.setFont('helvetica', 'bold');
                        doc.text(code, marginX, currentY);
                        doc.setFont('helvetica', 'normal');
                        flattenedLabel.forEach((line) => {
                            ensureSpace(lineHeight);
                            doc.text(line, marginX + 12, currentY);
                            currentY += lineHeight;
                        });
                        const metrics = `Tot ${total} • Pres ${presenceValue} • Dist ${distanceValue}`;
                        ensureSpace(lineHeight);
                        doc.text(metrics, marginX + 12, currentY);
                        currentY += lineHeight;
                    });
                    currentY += lineHeight;
                }
            });
        });

        const filenameSafe = levelData.name.replace(/\s+/g, '_').replace(/[^A-Za-z0-9_\-]/g, '');
        doc.save(`Piano_${filenameSafe || 'curriculum'}.pdf`);
        this.showToast('PDF generato con successo.');
    }

    formatHourLabel(value) {
        const number = Number.isFinite(value) ? Number(value) : 0;
        return `${number} h`;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CurriculumPlanner(curriculumModel);
});
