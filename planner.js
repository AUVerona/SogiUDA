const curriculumModel = {
    Alpha: {
        name: 'Percorso Alpha',
        description: 'Livelli A1 e A2 del Quadro Comune Europeo di Riferimento per le lingue.',
        levels: [
            {
                id: 'alpha-a1',
                name: 'Livello A1 (Quadro Comune Europeo di Riferimento per le lingue)',
                sections: [
                    {
                        id: 'alpha-a1-ascolto',
                        title: 'Ascolto',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-ascolto-1',
                                code: '1',
                                label: 'Comprendere istruzioni che vengono impartite purché si parli lentamente e chiaramente.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-ascolto-2',
                                code: '2',
                                label: 'Comprendere un discorso pronunciato molto lentamente e articolato con grande precisione, che contenga lunghe pause per permettere di assimilarne il senso.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a1-lettura',
                        title: 'Lettura',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-lettura-3',
                                code: '3',
                                label: 'Comprendere testi molto brevi e semplici, cogliendo nomi conosciuti, parole ed espressioni familiari ed eventualmente rileggendo.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a1-interazione',
                        title: 'Interazione orale e scritta',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-interazione-4',
                                code: '4',
                                label: 'Porre e rispondere a semplici domande relative a se stessi, alle azioni quotidiane e ai luoghi dove si vive.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-interazione-5',
                                code: '5',
                                label: 'Utilizzare in uno scambio comunicativo numeri, quantità, costi, orari.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-interazione-6',
                                code: '6',
                                label: 'Compilare un semplice modulo con i propri dati anagrafici.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a1-produzione-orale',
                        title: 'Produzione orale',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-produzione-orale-7',
                                code: '7',
                                label: 'Descrivere se stessi, le azioni quotidiane e i luoghi dove si vive.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-produzione-orale-8',
                                code: '8',
                                label: 'Formulare espressioni semplici, prevalentemente isolate, su persone e luoghi.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a1-produzione-scritta',
                        title: 'Produzione scritta',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a1-produzione-scritta-9',
                                code: '9',
                                label: 'Scrivere i propri dati anagrafici, numeri e date.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a1-produzione-scritta-10',
                                code: '10',
                                label: 'Scrivere semplici espressioni e frasi isolate.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    }
                ]
            },
            {
                id: 'alpha-a2',
                name: 'Livello A2 (Quadro Comune Europeo di Riferimento per le lingue)',
                sections: [
                    {
                        id: 'alpha-a2-ascolto',
                        title: 'Ascolto',
                        totalHours: 15,
                        subtopics: [
                            {
                                id: 'alpha-a2-ascolto-1',
                                code: '1',
                                label: 'Comprendere quanto basta per soddisfare bisogni di tipo concreto, purché si parli lentamente e chiaramente.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-ascolto-2',
                                code: '2',
                                label: 'Comprendere espressioni riferite ad aree di priorità immediata quali la persona, la famiglia, gli acquisti, la geografia locale e il lavoro, purché si parli lentamente e chiaramente.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a2-lettura',
                        title: 'Lettura',
                        totalHours: 20,
                        subtopics: [
                            {
                                id: 'alpha-a2-lettura-3',
                                code: '3',
                                label: 'Comprendere testi brevi e semplici di contenuto familiare e di tipo concreto, formulati nel linguaggio che ricorre frequentemente nella vita di tutti i giorni e/o sul lavoro.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a2-interazione',
                        title: 'Interazione orale e scritta',
                        totalHours: 15,
                        subtopics: [
                            {
                                id: 'alpha-a2-interazione-4',
                                code: '4',
                                label: 'Far fronte a scambi di routine, ponendo e rispondendo a domande semplici.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-interazione-5',
                                code: '5',
                                label: 'Scambiare informazioni su argomenti e attività consuete riferite alla famiglia, all’ambiente, al lavoro e al tempo libero.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-interazione-6',
                                code: '6',
                                label: 'Scrivere brevi e semplici appunti, relativi a bisogni immediati, usando formule convenzionali.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a2-produzione-orale',
                        title: 'Produzione orale',
                        totalHours: 15,
                        subtopics: [
                            {
                                id: 'alpha-a2-produzione-orale-7',
                                code: '7',
                                label: 'Descrivere o presentare in modo semplice persone, condizioni di vita o di lavoro, compiti quotidiani.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-produzione-orale-8',
                                code: '8',
                                label: 'Usare semplici espressioni e frasi legate insieme per indicare le proprie preferenze.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'alpha-a2-produzione-scritta',
                        title: 'Produzione scritta',
                        totalHours: 15,
                        subtopics: [
                            {
                                id: 'alpha-a2-produzione-scritta-9',
                                code: '9',
                                label: 'Scrivere una serie di elementari espressioni e frasi legate da semplici connettivi quali “e”, “ma”, “perché” relativi a contesti di vita sociali, culturali e lavorativi.',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'alpha-a2-produzione-scritta-10',
                                code: '10',
                                label: 'Scrivere una semplice lettera personale su argomenti e attività consuete riferite alla famiglia, all’ambiente, al lavoro e al tempo libero.',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    }
                ]
            }
        ]
    },
    Primo: {
        name: 'Percorso Primo',
        description: 'Competenze organizzate per assi culturali secondo il decreto del Ministero della Pubblica Istruzione.',
        levels: [
            {
                id: 'primo-competenze',
                name: 'Competenze',
                sections: [
                    {
                        id: 'primo-asse-linguaggi',
                        title: 'Asse dei Linguaggi',
                        totalHours: 198,
                        subtopics: [
                            {
                                id: 'primo-linguaggi-1',
                                code: '1',
                                label: 'Interagire oralmente in maniera efficace e collaborativa con un registro linguistico appropriato alle diverse situazioni comunicative',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-linguaggi-2',
                                code: '2',
                                label: 'Leggere, comprendere ed interpretare testi scritti di vario tipo',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-linguaggi-3',
                                code: '3',
                                label: 'Produrre testi di vario tipo adeguati ai diversi contesti',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-linguaggi-4',
                                code: '4',
                                label: 'Riconoscere e descrivere i beni del patrimonio artistico e culturale anche ai fini della tutela e conservazione',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-linguaggi-5',
                                code: '5',
                                label: 'Utilizzare le tecnologie dell\'informazione per ricercare e analizzare dati e informazioni',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-linguaggi-6',
                                code: '6',
                                label: 'Comprendere gli aspetti culturali e comunicativi dei linguaggi non verbali',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-linguaggi-7',
                                code: '7',
                                label: 'Utilizzare la lingua inglese per i principali scopi comunicativi riferiti ad aspetti del proprio vissuto e del proprio ambiente',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-linguaggi-8',
                                code: '8',
                                label: 'Comprendere e utilizzare una seconda lingua comunitaria in scambi di informazioni semplici e diretti su argomenti familiari e abituali',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'primo-asse-storico-sociale',
                        title: 'Asse Storico-Sociale',
                        totalHours: 66,
                        subtopics: [
                            {
                                id: 'primo-storico-sociale-9',
                                code: '9',
                                label: 'Orientarsi nella complessità del presente utilizzando la comprensione dei fatti storici, geografici e sociali del passato, anche al fine di confrontarsi con opinioni e culture diverse',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-storico-sociale-10',
                                code: '10',
                                label: 'Analizzare sistemi territoriali vicini e lontani nello spazio e nel tempo per valutare gli effetti dell\'azione dell\'uomo',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-storico-sociale-11',
                                code: '11',
                                label: 'Leggere e interpretare le trasformazioni del mondo del lavoro',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-storico-sociale-12',
                                code: '12',
                                label: 'Esercitare la cittadinanza attiva come espressione dei principi di legalità, solidarietà e partecipazione democratica',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'primo-asse-matematico',
                        title: 'Asse Matematico',
                        totalHours: 66,
                        subtopics: [
                            {
                                id: 'primo-matematico-13',
                                code: '13',
                                label: 'Operare con i numeri interi e razionali padroneggiandone scrittura e proprietà formali',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-matematico-14',
                                code: '14',
                                label: 'Riconoscere e confrontare figure geometriche del piano e dello spazio individuando invarianti e relazioni',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-matematico-15',
                                code: '15',
                                label: 'Registrare, ordinare, correlare dati e rappresentarli anche valutando la probabilità di un evento',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-matematico-16',
                                code: '16',
                                label: 'Affrontare situazioni problematiche traducendole in termini matematici, sviluppando correttamente il procedimento risolutivo e verificando l\'attendibilità dei risultati',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'primo-asse-scientifico-tecnologico',
                        title: 'Asse Scientifico-Tecnologico',
                        totalHours: 66,
                        subtopics: [
                            {
                                id: 'primo-scientifico-17',
                                code: '17',
                                label: 'Osservare, analizzare e descrivere fenomeni appartenenti alla realtà naturale e artificiale',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-scientifico-18',
                                code: '18',
                                label: 'Analizzare la rete di relazioni tra esseri viventi e tra viventi e ambiente, individuando anche le interazioni ai vari livelli e negli specifici contesti ambientali dell\'organizzazione biologica',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-scientifico-19',
                                code: '19',
                                label: 'Considerare come i diversi ecosistemi possono essere modificati dai processi naturali e dall\'azione dell\'uomo e adottare modi di vita ecologicamente responsabili',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-scientifico-20',
                                code: '20',
                                label: 'Progettare e realizzare semplici prodotti anche di tipo digitale utilizzando risorse materiali, informative, organizzative e oggetti, strumenti e macchine di uso comune',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-scientifico-21',
                                code: '21',
                                label: 'Orientarsi sui benefici e sui problemi economici ed ecologici legati alle varie modalità di produzione dell\'energia e alle scelte di tipo tecnologico',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'primo-scientifico-22',
                                code: '22',
                                label: 'Riconoscere le proprietà e le caratteristiche dei diversi mezzi di comunicazione per un loro uso efficace e responsabile rispetto alle proprie necessità di studio, di socializzazione e di lavoro',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    }
                ]
            }
        ]
    },
    SecondoLivello: {
        name: 'Secondo livello',
        description: 'Seleziona il periodo didattico e la classe per accedere alle competenze.',
        isSecondLevelSelector: true,
        periods: {
            'primo-periodo': {
                id: 'primo-periodo',
                name: 'Primo Periodo Didattico',
                classes: {
                    'classe-i': {
                        id: 'classe-i',
                        name: 'I',
                        sections: [
                            {
                                id: 'primo-periodo-i-italiano',
                                title: 'Lingua e letteratura italiana',
                                totalHours: 99,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-i-inglese',
                                title: 'Lingua Inglese',
                                totalHours: 66,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-i-matematica',
                                title: 'Matematica',
                                totalHours: 99,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-i-scienze',
                                title: 'Scienze integrate',
                                totalHours: 99,
                                subtopics: []
                            }
                        ]
                    },
                    'classe-ii': {
                        id: 'classe-ii', 
                        name: 'II',
                        sections: [
                            {
                                id: 'primo-periodo-ii-italiano',
                                title: 'Lingua e letteratura italiana',
                                totalHours: 99,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-ii-inglese',
                                title: 'Lingua Inglese',
                                totalHours: 66,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-ii-storia',
                                title: 'Storia',
                                totalHours: 99,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-ii-diritto',
                                title: 'Diritto ed Economia',
                                totalHours: 66,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-ii-matematica',
                                title: 'Matematica',
                                totalHours: 99,
                                subtopics: []
                            }
                        ]
                    },
                    'completo': {
                        id: 'completo',
                        name: 'Completo',
                        sections: [
                            {
                                id: 'primo-periodo-completo-italiano',
                                title: 'Lingua e letteratura italiana',
                                totalHours: 198,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-completo-inglese',
                                title: 'Lingua Inglese',
                                totalHours: 132,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-completo-storia',
                                title: 'Storia',
                                totalHours: 99,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-completo-diritto',
                                title: 'Diritto ed Economia',
                                totalHours: 66,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-completo-matematica',
                                title: 'Matematica',
                                totalHours: 198,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-completo-scienze',
                                title: 'Scienze Integrate',
                                totalHours: 99,
                                subtopics: []
                            },
                            {
                                id: 'primo-periodo-completo-religione',
                                title: 'Religione Cattolica',
                                totalHours: 33,
                                subtopics: []
                            }
                        ]
                    }
                }
            },
            'secondo-periodo': {
                id: 'secondo-periodo',
                name: 'Secondo Periodo Didattico',
                classes: {
                    'classe-iii': {
                        id: 'classe-iii',
                        name: 'III',
                        sections: []
                    },
                    'classe-iv': {
                        id: 'classe-iv',
                        name: 'IV', 
                        sections: []
                    },
                    'completo': {
                        id: 'completo',
                        name: 'Completo',
                        sections: []
                    }
                }
            },
            'terzo-periodo': {
                id: 'terzo-periodo',
                name: 'Terzo Periodo Didattico',
                sections: []
            }
        }
    },
    Secondo: {
        name: 'Percorso Secondo',
        description: 'Secondo livello di competenze organizzate per assi culturali.',
        levels: [
            {
                id: 'secondo-competenze',
                name: 'Competenze - Secondo Livello',
                sections: [
                    {
                        id: 'secondo-asse-linguaggi',
                        title: 'Asse dei Linguaggi',
                        totalHours: 330,
                        subtopics: [
                            {
                                id: 'secondo-linguaggi-1',
                                code: '1',
                                label: 'Padroneggiare gli strumenti espressivi ed argomentativi indispensabili per gestire l\'interazione comunicativa verbale in vari contesti',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-linguaggi-2',
                                code: '2',
                                label: 'Leggere, comprendere ed interpretare testi scritti di vario tipo',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-linguaggi-3',
                                code: '3',
                                label: 'Produrre testi di vario tipo in relazione ai differenti scopi comunicativi',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-linguaggi-4',
                                code: '4',
                                label: 'Utilizzare gli strumenti fondamentali per una fruizione consapevole del patrimonio artistico e letterario',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-linguaggi-5',
                                code: '5',
                                label: 'Utilizzare la lingua inglese per i principali scopi comunicativi ed operativi',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-linguaggi-6',
                                code: '6',
                                label: 'Produrre testi di vario tipo in lingua inglese in relazione ai differenti scopi comunicativi',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'secondo-asse-storico-sociale-economico',
                        title: 'Asse Storico-Sociale-Economico',
                        totalHours: 165,
                        subtopics: [
                            {
                                id: 'secondo-storico-sociale-7',
                                code: '7',
                                label: 'Comprendere il cambiamento e le diversità dei tempi storici in una dimensione diacronica attraverso il confronto fra epoche e in una dimensione sincronica attraverso il confronto fra aree geografiche e culturali',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-storico-sociale-8',
                                code: '8',
                                label: 'Collocare l\'esperienza personale in un sistema di regole fondato sul reciproco riconoscimento dei diritti garantiti dalla Costituzione, a tutela della persona, della collettività e dell\'ambiente',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-storico-sociale-9',
                                code: '9',
                                label: 'Riconoscere le caratteristiche essenziali del sistema socio economico per orientarsi nel tessuto produttivo del proprio territorio',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'secondo-asse-matematico',
                        title: 'Asse Matematico',
                        totalHours: 198,
                        subtopics: [
                            {
                                id: 'secondo-matematico-10',
                                code: '10',
                                label: 'Utilizzare le tecniche e le procedure del calcolo aritmetico ed algebrico rappresentandole anche sotto forma grafica',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-matematico-11',
                                code: '11',
                                label: 'Confrontare ed analizzare figure geometriche, individuando invarianti e relazioni',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-matematico-12',
                                code: '12',
                                label: 'Individuare le strategie appropriate per la soluzione di problemi',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-matematico-13',
                                code: '13',
                                label: 'Analizzare dati e interpretarli sviluppando deduzioni e ragionamenti sugli stessi anche con l\'ausilio di rappresentazioni grafiche, usando consapevolmente gli strumenti di calcolo e le potenzialità offerte da applicazioni specifiche di tipo informatico',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    },
                    {
                        id: 'secondo-asse-scientifico-tecnologico',
                        title: 'Asse Scientifico-Tecnologico',
                        totalHours: 99,
                        subtopics: [
                            {
                                id: 'secondo-scientifico-14',
                                code: '14',
                                label: 'Osservare, descrivere ed analizzare fenomeni appartenenti alla realtà naturale e artificiale e riconoscere nelle varie forme i concetti di sistema e di complessità',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-scientifico-15',
                                code: '15',
                                label: 'Analizzare qualitativamente e quantitativamente fenomeni legati alle trasformazioni di energia a partire dall\'esperienza',
                                hours: 0,
                                distanceHours: 0
                            },
                            {
                                id: 'secondo-scientifico-16',
                                code: '16',
                                label: 'Essere consapevole delle potenzialità e dei limiti delle tecnologie nel contesto culturale e sociale in cui vengono applicate',
                                hours: 0,
                                distanceHours: 0
                            }
                        ]
                    }
                ]
            }
        ]
    }
};

class CurriculumPlanner {
    constructor(model) {
        this.data = JSON.parse(JSON.stringify(model));
        this.state = {
            selectedLevel: null,
            toastTimer: null
        };
        this.distanceCapRatio = 0.2;
        this.minimumHoursPerSubtopic = 1;

        this.elements = {
            detailsPanel: document.getElementById('details-panel'),
            summaryPanel: document.getElementById('summary-panel'),
            summaryContent: document.getElementById('summary-content'),
            toast: document.getElementById('toast'),
            levelButtons: Array.from(document.querySelectorAll('.level-button')),
            printButton: document.getElementById('print-plan')
        };

        this.initializeMinimumHours();
        this.bindEvents();
        this.render();
    }

    bindEvents() {
        this.elements.levelButtons.forEach((button) => {
            button.addEventListener('click', () => this.setLevel(button.dataset.level));
        });

        if (this.elements.printButton) {
            this.elements.printButton.addEventListener('click', () => this.exportToPdf());
        }

        // Event delegation per i pulsanti UDA
        this.elements.detailsPanel.addEventListener('click', (event) => {
            const udaButton = event.target.closest('.add-uda-button');
            if (udaButton) {
                this.handleAddUDA(event);
                return;
            }
            
            const editButton = event.target.closest('.edit-uda-button');
            if (editButton) {
                this.handleEditUDA(event);
                return;
            }
            
            const deleteButton = event.target.closest('.delete-uda-button');
            if (deleteButton) {
                this.handleDeleteUDA(event);
                return;
            }
        });
    }

    setLevel(levelKey) {
        if (this.state.selectedLevel === levelKey) {
            return;
        }

        this.state.selectedLevel = levelKey;

        this.elements.levelButtons.forEach((button) => {
            const isActive = button.dataset.level === levelKey;
            button.classList.toggle('active', isActive);
            button.setAttribute('aria-pressed', String(isActive));
        });

        // Gestisci layout speciale per Secondo Livello
        const layoutElement = document.querySelector('.layout');
        const detailsPanel = this.elements.detailsPanel;
        
        if (levelKey === 'SecondoLivello') {
            layoutElement?.classList.add('second-level-layout');
            detailsPanel?.classList.add('second-level-active');
        } else {
            layoutElement?.classList.remove('second-level-layout');
            detailsPanel?.classList.remove('second-level-active');
        }

        this.renderDetails();
        this.renderSummary();
        this.scrollToDetails();
    }

    render() {
        this.renderDetails();
        this.renderSummary();
    }

    renderDetails() {
        const container = this.elements.detailsPanel;
        const levelKey = this.state.selectedLevel;

        if (!levelKey) {
            container.innerHTML = `
                <div class="empty-state">
                    <h2>Seleziona un percorso per iniziare</h2>
                    <p>Scegli <strong>Alpha</strong>, <strong>Primo</strong>, <strong>Secondo livello</strong> o <strong>Secondo</strong> per visualizzare la struttura delle attività.</p>
                </div>
            `;
            if (this.elements.printButton) {
                this.elements.printButton.disabled = true;
                this.elements.printButton.setAttribute('aria-disabled', 'true');
            }
            return;
        }

        const levelData = this.data[levelKey];

        if (!levelData) {
            container.innerHTML = `
                <div class="empty-state">
                    <h2>Percorso non disponibile</h2>
                    <p>Contenuti non ancora configurati.</p>
                </div>
            `;
            if (this.elements.printButton) {
                this.elements.printButton.disabled = true;
                this.elements.printButton.setAttribute('aria-disabled', 'true');
            }
            return;
        }

        // Caso speciale per Secondo Livello con selettore di periodi
        if (levelData.isSecondLevelSelector && levelData.periods) {
            container.innerHTML = this.renderMainPeriodSelector(levelData);
            this.attachSecondLevelInteractions();
            if (this.elements.printButton) {
                this.elements.printButton.disabled = false;
                this.elements.printButton.setAttribute('aria-disabled', 'false');
            }
            return;
        }

        if (!levelData.levels || levelData.levels.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <h2>${levelData.name}</h2>
                    <p>${levelData.description}</p>
                </div>
            `;
            if (this.elements.printButton) {
                this.elements.printButton.disabled = true;
                this.elements.printButton.setAttribute('aria-disabled', 'true');
            }
            return;
        }

        const markup = levelData.levels.map((level) => this.renderLevel(level)).join('');
        container.innerHTML = markup;
        this.attachInteractions();

        if (this.elements.printButton) {
            this.elements.printButton.disabled = false;
            this.elements.printButton.setAttribute('aria-disabled', 'false');
        }
    }

    renderMainPeriodSelector(levelData) {
        const periods = Object.values(levelData.periods);
        
        return `
            <div class="second-level-container">
                <div class="second-level-header">
                    <h2 class="second-level-title">${levelData.name}</h2>
                    <p class="second-level-description">${levelData.description}</p>
                </div>
                
                <div class="period-selection-form">
                    <fieldset class="period-fieldset">
                        <legend class="period-legend">Seleziona il Periodo Didattico</legend>
                        <div class="period-buttons" role="tablist" aria-label="Periodi didattici">
                            ${periods.map(period => `
                                <button 
                                    type="button" 
                                    class="period-button" 
                                    role="tab"
                                    id="tab-${period.id}"
                                    data-period-id="${period.id}"
                                    aria-selected="false"
                                    aria-controls="panel-${period.id}"
                                    tabindex="-1"
                                >
                                    ${period.name}
                                </button>
                            `).join('')}
                        </div>
                    </fieldset>
                    
                    <div class="period-content-area">
                        ${periods.map(period => `
                            <div 
                                class="period-content-panel"
                                role="tabpanel" 
                                id="panel-${period.id}"
                                aria-labelledby="tab-${period.id}"
                                hidden
                            >
                                ${this.renderPeriodPanel(period)}
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
    }

    renderPeriodPanel(period) {
        // Se ha classi (primo e secondo periodo)
        if (period.classes) {
            const classes = Object.values(period.classes);
            return `
                <div class="class-selection-section">
                    <h3 class="period-panel-title">${period.name}</h3>
                    <fieldset class="class-fieldset">
                        <legend class="class-legend">Seleziona la Classe</legend>
                        <div class="class-buttons" role="tablist" aria-label="Classi disponibili">
                            ${classes.map(classItem => `
                                <button 
                                    type="button" 
                                    class="class-button" 
                                    role="tab"
                                    id="tab-${period.id}-${classItem.id}"
                                    data-period-id="${period.id}"
                                    data-class-id="${classItem.id}"
                                    aria-selected="false"
                                    aria-controls="content-${period.id}-${classItem.id}"
                                    tabindex="-1"
                                >
                                    ${classItem.name}
                                </button>
                            `).join('')}
                        </div>
                    </fieldset>
                    
                    <div class="class-content-area">
                        ${classes.map(classItem => `
                            <div 
                                class="class-content-panel"
                                role="tabpanel" 
                                id="content-${period.id}-${classItem.id}"
                                aria-labelledby="tab-${period.id}-${classItem.id}"
                                hidden
                            >
                                ${this.renderClassContent(classItem, period.id)}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        } else {
            // Terzo periodo - contenuto diretto
            return `
                <div class="direct-content-section">
                    <h3 class="period-panel-title">${period.name}</h3>
                    ${this.renderDirectPeriodContent(period)}
                </div>
            `;
        }
    }

    renderClassContent(classItem, periodId) {
        if (!classItem.sections || classItem.sections.length === 0) {
            return `
                <div class="class-empty-state">
                    <h4 class="class-content-title">Classe ${classItem.name}</h4>
                    <p class="class-empty-message">Contenuti in fase di definizione per questa classe.</p>
                </div>
            `;
        }

        return `
            <div class="class-content">
                <h4 class="class-content-title">Classe ${classItem.name}</h4>
                <div class="section-grid">
                    ${classItem.sections.map((section) => this.renderSection(section)).join('')}
                </div>
            </div>
        `;
    }

    renderDirectPeriodContent(period) {
        if (!period.sections || period.sections.length === 0) {
            return `
                <div class="period-empty-state">
                    <p class="period-empty-message">Contenuti in fase di definizione per questo periodo.</p>
                </div>
            `;
        }

        return `
            <div class="period-direct-content">
                <div class="section-grid">
                    ${period.sections.map((section) => this.renderSection(section)).join('')}
                </div>
            </div>
        `;
    }

    renderLevel(level) {
        // Se è un livello con menu, mostra i pulsanti del menu
        if (level.isMenuLevel) {
            return `
                <article class="level-block menu-level" data-level-id="${level.id}">
                    <div class="level-block__header">
                        <div class="level-block__meta">
                            <h2 class="level-block__title">${level.name}</h2>
                        </div>
                    </div>
                    <div class="period-selector-form">
                        <div class="period-tabs">
                            ${level.menuItems.map(item => `
                                <button type="button" class="period-tab" data-menu-item="${item.id}" data-level-id="${level.id}">
                                    ${item.name}
                                </button>
                            `).join('')}
                        </div>
                        <div class="period-content" id="menu-content-${level.id}"></div>
                    </div>
                </article>
            `;
        }

        // Rendering normale per livelli standard
        const totals = this.computeLevelTotals(level);

        return `
            <article class="level-block" data-level-id="${level.id}">
                <div class="level-block__header">
                    <div class="level-block__meta">
                        <h2 class="level-block__title">${level.name}</h2>
                        <p class="level-description">Totale ore previste: <strong>${totals.total}</strong></p>
                    </div>
                    <div class="capsule">${totals.assigned}/${totals.total} ore assegnate</div>
                </div>
                <div class="section-grid">
                    ${level.sections.map((section) => this.renderSection(section)).join('')}
                </div>
            </article>
        `;
    }

    renderSection(section) {
        const allocated = this.sectionAllocated(section);
        const remaining = this.sectionRemaining(section);
        const completion = section.totalHours > 0 ? Math.min(100, Math.round((allocated / section.totalHours) * 100)) : 0;
        const statusText = remaining === 0 && section.totalHours > 0
            ? 'Distribuzione completata'
            : `Ore da assegnare: ${remaining}`;
        const cardClasses = ['section-card'];
        const distanceCap = this.sectionDistanceCap(section);
        const distanceAllocated = this.sectionDistanceAllocated(section);
        const distanceRemaining = Math.max(0, distanceCap - distanceAllocated);
        const distanceStatus = distanceCap === 0
            ? 'Nessuna attività a distanza consentita per questa sezione.'
            : distanceRemaining === 0
                ? 'Limite ore distanza raggiunto.'
                : `Ore a distanza disponibili: ${distanceRemaining}`;
        const distanceClasses = ['section-distance'];
        if (distanceRemaining === 0 && distanceCap > 0) {
            distanceClasses.push('--limit');
        }

        if (remaining === 0 && section.totalHours > 0) {
            cardClasses.push('complete');
        }

        return `
            <div class="${cardClasses.join(' ')}" data-section-id="${section.id}">
                <div class="section-card__top">
                    <div class="section-card__meta">
                        <h3 class="section-title">${section.title}</h3>
                        <span class="capsule">${section.totalHours} ore totali</span>
                    </div>
                    <div class="section-feedback${remaining === 0 ? '' : ' --warning'}">
                        <span class="section-feedback__counter">Assegnate <strong>${allocated}</strong> ore</span>
                        <span class="section-feedback__status">${statusText}</span>
                    </div>
                </div>
                <div class="progress">
                    <div class="progress__bar" style="width: ${completion}%;"></div>
                </div>
                ${distanceAllocated > 0 || distanceCap > 0 ? `
                <div class="${distanceClasses.join(' ')}">
                    <span class="section-distance__counter">Ore distanza: <strong>${distanceAllocated}</strong>${distanceCap > 0 ? ` / ${distanceCap}` : ''}</span>
                    <span class="section-distance__status">${distanceStatus}</span>
                </div>
                ` : ''}
                <div class="subtopics">
                    ${section.subtopics.map((subtopic) => this.renderSubtopic(section, subtopic)).join('')}
                    ${this.renderAddUDAButton(section)}
                </div>
            </div>
        `;
    }

    renderAddUDAButton(section) {
        // Mostra il pulsante UDA solo nel SecondoLivello
        if (this.state.selectedLevel !== 'SecondoLivello') {
            return '';
        }

        const remaining = this.sectionRemaining(section);
        const remainingText = remaining > 0 
            ? `(${remaining} ore disponibili)`
            : '(0 ore disponibili - puoi comunque aggiungere UDA)';

        return `
            <div class="add-subtopic-container">
                <button type="button" class="add-uda-button" data-section-id="${section.id}">
                    <span class="add-icon">+</span>
                    <span class="add-text">Aggiungi UDA</span>
                    <span class="remaining-hours">${remainingText}</span>
                </button>
            </div>
        `;
    }

    renderSubtopic(section, subtopic) {
        const minimumHours = section.totalHours > 0 ? this.minimumHoursPerSubtopic : 0;
        
        // Calcola la percentuale considerando il range effettivo (da minimumHours a totalHours)
        let percent = 0;
        if (section.totalHours > 0) {
            const effectiveValue = subtopic.hours - minimumHours;
            const effectiveMax = section.totalHours - minimumHours;
            percent = effectiveMax > 0 ? Math.round((effectiveValue / effectiveMax) * 100) : 0;
        }
        
        const sliderBackground = this.buildSliderGradient(percent);
        const presenceHours = Math.max(0, subtopic.hours - (subtopic.distanceHours || 0));
        const sectionCap = this.sectionDistanceCap(section);
        const distanceAllocated = this.sectionDistanceAllocated(section);
        const currentDistance = subtopic.distanceHours || 0;
        const otherDistance = distanceAllocated - currentDistance;
        const remainingForSection = Math.max(0, sectionCap - otherDistance);
        const maxAllowedForThis = Math.min(subtopic.hours, remainingForSection);
        const sliderMax = sectionCap;
        const distanceDisabled = sectionCap === 0;
        const effectiveDistance = subtopic.distanceHours || 0;
        const distancePercent = sectionCap > 0 ? Math.min(100, Math.round((effectiveDistance / sectionCap) * 100)) : 0;
        const distanceSliderBg = this.buildDistanceSliderGradient(distancePercent);

        return `
            <div class="subtopic" data-section-id="${section.id}" data-subtopic-id="${subtopic.id}">
                <div class="subtopic-header">
                    <div class="subtopic-info">
                        <span class="subtopic-code">${subtopic.code ? subtopic.code + '.' : ''}</span>
                        <span class="subtopic-title">${subtopic.label}</span>
                    </div>
                    <div class="subtopic-badges">
                        ${subtopic.hours > 0 ? `<span class="subtopic-hours">${subtopic.hours} h totali</span>` : ''}
                        ${(subtopic.distanceHours || 0) > 0 ? `<span class="subtopic-distance-tag">${subtopic.distanceHours} h distanza</span>` : ''}
                    </div>
                    ${this.state.selectedLevel === 'SecondoLivello' ? `
                        <div class="subtopic-actions">
                            <button type="button" class="edit-uda-button" data-section-id="${section.id}" data-subtopic-id="${subtopic.id}" title="Modifica UDA">
                                <span class="edit-icon">✏️</span>
                            </button>
                            <button type="button" class="delete-uda-button" data-section-id="${section.id}" data-subtopic-id="${subtopic.id}" title="Elimina UDA">
                                <span class="delete-icon">🗑️</span>
                            </button>
                        </div>
                    ` : ''}
                </div>
                ${subtopic.description ? `<div class="uda-description">${subtopic.description}</div>` : ''}
                <div class="subtopic-distribution">
                    <span>Presenza: <strong>${presenceHours}</strong> h</span>
                    <span>Distanza: <strong>${subtopic.distanceHours}</strong> h</span>
                </div>
                <div class="subtopic-controls">
                    <input
                        type="range"
                        class="subtopic-slider"
                        min="${minimumHours}"
                        max="${section.totalHours}"
                        value="${subtopic.hours}"
                        data-section-id="${section.id}"
                        data-subtopic-id="${subtopic.id}"
                        aria-label="Ore assegnate per ${subtopic.label}"
                        style="background: ${sliderBackground};"
                    />
                    <div class="subtopic-inputs">
                        <div class="input-group">
                            <label for="input-${subtopic.id}">Ore totali</label>
                            <input
                                id="input-${subtopic.id}"
                                type="number"
                                class="subtopic-input"
                                min="${minimumHours}"
                                max="${section.totalHours}"
                                step="1"
                                value="${subtopic.hours}"
                                data-section-id="${section.id}"
                                data-subtopic-id="${subtopic.id}"
                            />
                        </div>
                        <div class="input-group">
                            <label for="presence-${subtopic.id}">Ore in presenza</label>
                            <input
                                id="presence-${subtopic.id}"
                                type="number"
                                class="subtopic-presence-input"
                                min="0"
                                step="1"
                                value="${presenceHours}"
                                readonly
                                aria-label="Ore in presenza per ${subtopic.label} (calcolato automaticamente)"
                            />
                        </div>
                        <div class="input-group distance-group" data-cap="${sectionCap}" data-section-id="${section.id}">
                            <label for="distance-${subtopic.id}">Ore a distanza (<span class="distance-value">${subtopic.distanceHours}</span> h)</label>
                            <input
                                id="distance-${subtopic.id}"
                                type="range"
                                class="subtopic-distance-slider"
                                min="0"
                                max="${sliderMax}"
                                step="1"
                                value="${subtopic.distanceHours}"
                                data-section-id="${section.id}"
                                data-subtopic-id="${subtopic.id}"
                                data-cap="${sectionCap}"
                                style="background: ${distanceSliderBg};"
                                aria-valuemin="0"
                                aria-valuemax="${sliderMax}"
                                aria-valuenow="${subtopic.distanceHours}"
                                aria-label="Ore a distanza per ${subtopic.label} (cap sezione ${sectionCap}h, residuo ${Math.max(0, sectionCap - distanceAllocated)}h)"
                                ${distanceDisabled ? 'disabled' : ''}
                            />
                            <div class="distance-input-wrapper">
                                <label class="sr-only" for="distance-input-${subtopic.id}">Inserisci ore a distanza (valore numerico)</label>
                                <input
                                    id="distance-input-${subtopic.id}"
                                    type="number"
                                    class="subtopic-distance-input"
                                    min="0"
                                    max="${sliderMax}"
                                    step="1"
                                    value="${subtopic.distanceHours}"
                                    data-section-id="${section.id}"
                                    data-subtopic-id="${subtopic.id}"
                                    data-cap="${sectionCap}"
                                    aria-label="Ore a distanza per ${subtopic.label} (input numerico)"
                                    ${distanceDisabled ? 'disabled' : ''}
                                />
                                <span class="distance-input-max">/ ${sectionCap} h</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    attachSecondLevelInteractions() {
        this.initializePeriodTabs();
        this.initializeClassTabs();
        this.attachStandardInteractions();
    }

    initializePeriodTabs() {
        const periodButtons = this.elements.detailsPanel.querySelectorAll('.period-button');
        
        // Imposta il primo periodo come attivo di default
        if (periodButtons.length > 0) {
            this.activatePeriodTab(periodButtons[0]);
        }

        periodButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                this.activatePeriodTab(event.target);
            });

            button.addEventListener('keydown', (event) => {
                this.handlePeriodTabKeyNavigation(event, periodButtons);
            });
        });
    }

    activatePeriodTab(activeButton) {
        const periodId = activeButton.dataset.periodId;
        
        // Deattiva tutti i tab dei periodi
        const allPeriodButtons = this.elements.detailsPanel.querySelectorAll('.period-button');
        const allPeriodPanels = this.elements.detailsPanel.querySelectorAll('.period-content-panel');
        
        allPeriodButtons.forEach(btn => {
            btn.setAttribute('aria-selected', 'false');
            btn.setAttribute('tabindex', '-1');
            btn.classList.remove('active');
        });
        
        allPeriodPanels.forEach(panel => {
            panel.setAttribute('hidden', '');
        });

        // Attiva il tab selezionato
        activeButton.setAttribute('aria-selected', 'true');
        activeButton.setAttribute('tabindex', '0');
        activeButton.classList.add('active');
        activeButton.focus();

        // Mostra il pannello corrispondente
        const activePanel = this.elements.detailsPanel.querySelector(`#panel-${periodId}`);
        if (activePanel) {
            activePanel.removeAttribute('hidden');
            this.initializeClassTabsForPeriod(periodId);
        }
    }

    handlePeriodTabKeyNavigation(event, allButtons) {
        let targetButton = null;
        const currentIndex = Array.from(allButtons).indexOf(event.target);

        switch (event.key) {
            case 'ArrowLeft':
            case 'ArrowUp':
                event.preventDefault();
                targetButton = allButtons[currentIndex - 1] || allButtons[allButtons.length - 1];
                break;
            case 'ArrowRight':
            case 'ArrowDown':
                event.preventDefault();
                targetButton = allButtons[currentIndex + 1] || allButtons[0];
                break;
            case 'Home':
                event.preventDefault();
                targetButton = allButtons[0];
                break;
            case 'End':
                event.preventDefault();
                targetButton = allButtons[allButtons.length - 1];
                break;
        }

        if (targetButton) {
            this.activatePeriodTab(targetButton);
        }
    }

    initializeClassTabs() {
        // Questo verrà chiamato per inizializzare tutti i tab delle classi
        const activePeriod = this.elements.detailsPanel.querySelector('.period-button[aria-selected="true"]');
        if (activePeriod) {
            this.initializeClassTabsForPeriod(activePeriod.dataset.periodId);
        }
    }

    initializeClassTabsForPeriod(periodId) {
        const classButtons = this.elements.detailsPanel.querySelectorAll(`[data-period-id="${periodId}"].class-button`);
        
        // Imposta la prima classe come attiva di default
        if (classButtons.length > 0) {
            this.activateClassTab(classButtons[0]);
        }

        classButtons.forEach(button => {
            // Rimuovi listener precedenti per evitare duplicati
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
        });

        // Riattacca i listener ai nuovi pulsanti
        const newClassButtons = this.elements.detailsPanel.querySelectorAll(`[data-period-id="${periodId}"].class-button`);
        newClassButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                this.activateClassTab(event.target);
            });

            button.addEventListener('keydown', (event) => {
                this.handleClassTabKeyNavigation(event, newClassButtons);
            });
        });
    }

    activateClassTab(activeButton) {
        const periodId = activeButton.dataset.periodId;
        const classId = activeButton.dataset.classId;
        
        // Deattiva tutti i tab delle classi per questo periodo
        const allClassButtons = this.elements.detailsPanel.querySelectorAll(`[data-period-id="${periodId}"].class-button`);
        const allClassPanels = this.elements.detailsPanel.querySelectorAll(`[id^="content-${periodId}-"]`);
        
        allClassButtons.forEach(btn => {
            btn.setAttribute('aria-selected', 'false');
            btn.setAttribute('tabindex', '-1');
            btn.classList.remove('active');
        });
        
        allClassPanels.forEach(panel => {
            panel.setAttribute('hidden', '');
        });

        // Attiva il tab selezionato
        activeButton.setAttribute('aria-selected', 'true');
        activeButton.setAttribute('tabindex', '0');
        activeButton.classList.add('active');
        activeButton.focus();

        // Mostra il pannello corrispondente
        const activePanel = this.elements.detailsPanel.querySelector(`#content-${periodId}-${classId}`);
        if (activePanel) {
            activePanel.removeAttribute('hidden');
            // Riattacca le interazioni per il contenuto della classe
            this.attachInteractionsToContainer(activePanel);
        }
    }

    handleClassTabKeyNavigation(event, allButtons) {
        let targetButton = null;
        const currentIndex = Array.from(allButtons).indexOf(event.target);

        switch (event.key) {
            case 'ArrowLeft':
            case 'ArrowUp':
                event.preventDefault();
                targetButton = allButtons[currentIndex - 1] || allButtons[allButtons.length - 1];
                break;
            case 'ArrowRight':
            case 'ArrowDown':
                event.preventDefault();
                targetButton = allButtons[currentIndex + 1] || allButtons[0];
                break;
            case 'Home':
                event.preventDefault();
                targetButton = allButtons[0];
                break;
            case 'End':
                event.preventDefault();
                targetButton = allButtons[allButtons.length - 1];
                break;
        }

        if (targetButton) {
            this.activateClassTab(targetButton);
        }
    }

    attachStandardInteractions() {
        // Metodo per attaccare le interazioni standard (slider, input, etc.)
        const container = this.elements.detailsPanel;
        this.attachInteractionsToContainer(container);
        
        // I pulsanti UDA vengono gestiti tramite event delegation in bindEvents
    }

    attachInteractions() {
        // Gestione pulsanti periodo principale
        const mainPeriodButtons = this.elements.detailsPanel.querySelectorAll('.main-period-tab');
        mainPeriodButtons.forEach((button) => {
            button.addEventListener('click', this.handleMainPeriodClick);
        });

        // Gestione pulsanti sotto-periodo
        const subPeriodButtons = this.elements.detailsPanel.querySelectorAll('.sub-period-tab');
        subPeriodButtons.forEach((button) => {
            button.addEventListener('click', this.handleSubPeriodClick);
        });

        // Gestione pulsanti menu per livelli normali
        const menuButtons = this.elements.detailsPanel.querySelectorAll('.menu-item-button, .period-tab');
        menuButtons.forEach((button) => {
            button.addEventListener('click', this.handleMenuItemClick);
        });

        const sliders = this.elements.detailsPanel.querySelectorAll('.subtopic-slider');
        const inputs = this.elements.detailsPanel.querySelectorAll('.subtopic-input');
        const distanceSliders = this.elements.detailsPanel.querySelectorAll('.subtopic-distance-slider');
        const distanceInputs = this.elements.detailsPanel.querySelectorAll('.subtopic-distance-input');

        sliders.forEach((slider) => {
            slider.addEventListener('input', this.handleAllocationUpdate);
        });

        inputs.forEach((input) => {
            input.addEventListener('change', this.handleAllocationUpdate);
            input.addEventListener('input', (event) => {
                if (event.target.value === '') {
                    return;
                }
                this.handleAllocationUpdate(event);
            });
        });

        distanceSliders.forEach((slider) => {
            if (slider.disabled) {
                return;
            }
            slider.addEventListener('input', this.handleDistanceUpdate);
            slider.addEventListener('change', this.handleDistanceUpdate);
        });

        distanceInputs.forEach((input) => {
            if (input.disabled) {
                return;
            }
            input.addEventListener('change', this.handleDistanceUpdate);
            input.addEventListener('input', (event) => {
                if (event.target.value === '') {
                    return;
                }
                this.handleDistanceUpdate(event);
            });
        });
    }

    handleMainPeriodClick = (event) => {
        const periodId = event.target.dataset.periodId;
        if (!periodId) return;

        // Rimuovi classe active da tutti i pulsanti periodo principali
        const allMainPeriodButtons = this.elements.detailsPanel.querySelectorAll('.main-period-tab');
        allMainPeriodButtons.forEach(btn => btn.classList.remove('active'));

        // Aggiungi classe active al pulsante cliccato
        event.target.classList.add('active');

        // Nascondi tutti i pannelli dei periodi
        const allPeriodPanels = this.elements.detailsPanel.querySelectorAll('.period-panel');
        allPeriodPanels.forEach(panel => panel.style.display = 'none');

        // Mostra il pannello selezionato
        const selectedPanel = this.elements.detailsPanel.querySelector(`#period-panel-${periodId}`);
        if (selectedPanel) {
            selectedPanel.style.display = 'block';
        }

        // Riattacca le interazioni per il nuovo contenuto
        this.attachInteractionsToContainer(selectedPanel);
    };

    handleSubPeriodClick = (event) => {
        const menuItemId = event.target.dataset.menuItem;
        const periodId = event.target.dataset.periodId;
        
        if (!menuItemId || !periodId) return;

        // Trova il periodo e l'item del menu
        const levelKey = this.state.selectedLevel;
        const levelData = this.data[levelKey];
        if (!levelData || !levelData.periods) return;

        const period = levelData.periods.find(p => p.id === periodId);
        if (!period || !period.menuItems) return;

        const menuItem = period.menuItems.find(item => item.id === menuItemId);
        if (!menuItem) return;

        // Rimuovi classe active da tutti i pulsanti sotto-periodo dello stesso periodo
        const periodPanel = this.elements.detailsPanel.querySelector(`#period-panel-${periodId}`);
        if (!periodPanel) return;

        const subPeriodButtons = periodPanel.querySelectorAll('.sub-period-tab');
        subPeriodButtons.forEach(btn => btn.classList.remove('active'));

        // Aggiungi classe active al pulsante cliccato
        event.target.classList.add('active');

        // Mostra il contenuto del menu item
        const contentContainer = periodPanel.querySelector(`#sub-content-${periodId}`);
        if (!contentContainer) return;

        contentContainer.innerHTML = this.renderMenuItemContent(menuItem);
        this.attachInteractionsToContainer(contentContainer);
    };

    attachInteractionsToContainer(container) {
        if (!container) return;

        const sliders = container.querySelectorAll('.subtopic-slider');
        const inputs = container.querySelectorAll('.subtopic-input');
        const distanceSliders = container.querySelectorAll('.subtopic-distance-slider');
        const distanceInputs = container.querySelectorAll('.subtopic-distance-input');

        sliders.forEach((slider) => {
            slider.addEventListener('input', this.handleAllocationUpdate);
        });

        inputs.forEach((input) => {
            input.addEventListener('change', this.handleAllocationUpdate);
            input.addEventListener('input', (event) => {
                if (event.target.value === '') return;
                this.handleAllocationUpdate(event);
            });
        });

        distanceSliders.forEach((slider) => {
            if (slider.disabled) return;
            slider.addEventListener('input', this.handleDistanceUpdate);
            slider.addEventListener('change', this.handleDistanceUpdate);
        });

        distanceInputs.forEach((input) => {
            if (input.disabled) return;
            input.addEventListener('change', this.handleDistanceUpdate);
            input.addEventListener('input', (event) => {
                if (event.target.value === '') return;
                this.handleDistanceUpdate(event);
            });
        });

        // I pulsanti UDA vengono gestiti tramite event delegation
    }

    handleAddUDA = (event) => {
        const button = event.target.closest('.add-uda-button');
        if (!button) return;
        
        const sectionId = button.dataset.sectionId;
        if (!sectionId) return;

        event.preventDefault();
        event.stopPropagation();
        
        this.toggleUDAForm(sectionId, button);
    };

    showSubtopicModal(sectionId) {
        const context = this.findSection(sectionId);
        if (!context) return;

        const { section } = context;
        const remaining = this.sectionRemaining(section);

        if (remaining < this.minimumHoursPerSubtopic) {
            this.showToast(`Servono almeno ${this.minimumHoursPerSubtopic} ore disponibili per aggiungere una nuova sottovoce. Riduci le altre attività e riprova.`, 'warning');
            return;
        }

        // Crea il modal
        const modal = document.createElement('div');
        modal.className = 'subtopic-modal-overlay';
        modal.innerHTML = `
            <div class="subtopic-modal">
                <div class="subtopic-modal-header">
                    <h3>Aggiungi sottovoce</h3>
                    <button type="button" class="modal-close-button" aria-label="Chiudi modal">×</button>
                </div>
                <div class="subtopic-modal-body">
                    <p class="modal-section-info">Materia: <strong>${section.title}</strong></p>
                    <p class="modal-hours-info">Ore disponibili: <strong>${remaining}</strong></p>
                    
                    <div class="modal-form">
                        <div class="modal-field">
                            <label for="subtopic-title">Titolo della sottovoce:</label>
                            <input type="text" id="subtopic-title" class="modal-input" placeholder="Inserisci il titolo..." required>
                        </div>
                        <div class="modal-field">
                            <label for="subtopic-hours">Ore da assegnare:</label>
                            <input type="number" id="subtopic-hours" class="modal-input" min="${this.minimumHoursPerSubtopic}" max="${remaining}" value="${this.minimumHoursPerSubtopic}" required>
                            <span class="input-helper">Max: ${remaining} ore</span>
                        </div>
                    </div>
                </div>
                <div class="subtopic-modal-footer">
                    <button type="button" class="modal-button modal-cancel">Annulla</button>
                    <button type="button" class="modal-button modal-save">Salva</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Event listeners per il modal
        const closeButton = modal.querySelector('.modal-close-button');
        const cancelButton = modal.querySelector('.modal-cancel');
        const saveButton = modal.querySelector('.modal-save');
        const titleInput = modal.querySelector('#subtopic-title');
        const hoursInput = modal.querySelector('#subtopic-hours');

        const closeModal = () => {
            document.body.removeChild(modal);
        };

        closeButton.addEventListener('click', closeModal);
        cancelButton.addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeModal();
        });

        saveButton.addEventListener('click', () => {
            const title = titleInput.value.trim();
            const hours = parseInt(hoursInput.value);

            if (!title) {
                titleInput.focus();
                titleInput.style.borderColor = '#ef4444';
                return;
            }

            if (hours < this.minimumHoursPerSubtopic || hours > remaining) {
                hoursInput.focus();
                hoursInput.style.borderColor = '#ef4444';
                return;
            }

            this.addSubtopic(sectionId, title, hours);
            closeModal();
        });

        // Focus sul primo input
        titleInput.focus();

        // Gestione tasto Escape
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }

    addSubtopic(sectionId, title, hours) {
        const context = this.findSection(sectionId);
        if (!context) return;

        const { section } = context;
        
        // Genera un ID univoco per la sottovoce
        const subtopicId = `${sectionId}-subtopic-${section.subtopics.length + 1}`;
        
        // Crea la nuova sottovoce
        const minimumHours = this.minimumHoursPerSubtopic;
        const allocatedHours = Math.max(hours, minimumHours);

        const newSubtopic = {
            id: subtopicId,
            code: String(section.subtopics.length + 1),
            label: title,
            hours: allocatedHours,
            distanceHours: 0
        };

        // Aggiungi alla sezione
        section.subtopics.push(newSubtopic);

        // Aggiorna la visualizzazione
        this.refreshSection(sectionId);
        this.renderSummary();

        // Mostra messaggio di conferma
        this.showToast(`Sottovoce "${title}" aggiunta con ${allocatedHours} ore.`);
    }

    toggleUDAForm(sectionId, buttonElement) {
        // Chiudi eventuali altri modal aperti
        document.querySelectorAll('.subtopic-modal-overlay').forEach(modal => {
            if (modal.querySelector('.modal-save').textContent.includes('UDA')) {
                modal.remove();
            }
        });

        this.showUDAForm(sectionId, buttonElement);
    }

    handleEditUDA = (event) => {
        const button = event.target.closest('.edit-uda-button');
        if (!button) return;
        
        const sectionId = button.dataset.sectionId;
        const subtopicId = button.dataset.subtopicId;
        
        // Chiudi eventuali altri modal aperti
        document.querySelectorAll('.subtopic-modal-overlay').forEach(modal => modal.remove());

        this.showEditUDAForm(sectionId, subtopicId, button);
    }

    handleDeleteUDA = (event) => {
        const button = event.target.closest('.delete-uda-button');
        if (!button) return;
        
        const sectionId = button.dataset.sectionId;
        const subtopicId = button.dataset.subtopicId;
        
        this.confirmDeleteUDA(sectionId, subtopicId);
    }

    showUDAForm(sectionId, buttonElement) {
        const context = this.findSection(sectionId);
        if (!context) return;

        const { section } = context;
        const remaining = this.sectionRemaining(section);
        const sectionDistanceCap = this.sectionDistanceCap(section);
        const sectionDistanceAllocated = this.sectionDistanceAllocated(section);
        const maxDistanceAvailable = Math.max(0, sectionDistanceCap - sectionDistanceAllocated);

        if (remaining < this.minimumHoursPerSubtopic) {
            this.showToast(`Servono almeno ${this.minimumHoursPerSubtopic} ore disponibili per aggiungere una nuova UDA. Riduci le altre voci e riprova.`, 'warning');
            return;
        }

        const minimumHours = this.minimumHoursPerSubtopic;
        const initialTotalHours = Math.min(remaining, minimumHours);

        // Crea il modal popup
        const modal = document.createElement('div');
        modal.className = 'subtopic-modal-overlay';
        modal.innerHTML = `
            <div class="subtopic-modal">
                <div class="subtopic-modal-header">
                    <h3>Aggiungi UDA</h3>
                    <button type="button" class="modal-close-button" aria-label="Chiudi modal">×</button>
                </div>
                <div class="subtopic-modal-body">
                    <p class="modal-section-info">Materia: <strong>${section.title}</strong></p>
                    <p class="modal-hours-info">Ore disponibili: <strong>${remaining}</strong> ${remaining <= 0 ? '<span style="color: #d73502;">(Limite raggiunto - UDA aggiuntive sforeranno il totale)</span>' : ''}</p>
                    <p class="modal-distance-info">Limite ore a distanza: <strong>${maxDistanceAvailable}/${sectionDistanceCap}</strong> (20% del totale materia)</p>
                    
                    <div class="error-container" id="error-container-${sectionId}" style="display: none;">
                        <div class="error-message" id="error-message-${sectionId}"></div>
                    </div>
                    
                    <div class="modal-form">
                        <div class="modal-field">
                            <label for="uda-name-${sectionId}">Nome UDA:</label>
                            <input type="text" id="uda-name-${sectionId}" class="modal-input" placeholder="Inserisci il nome dell'UDA..." required>
                        </div>
                        
                        <div class="modal-field">
                            <label for="uda-description-${sectionId}">Descrizione:</label>
                            <textarea id="uda-description-${sectionId}" class="modal-input modal-textarea" rows="4" placeholder="Descrivi l'UDA..." required></textarea>
                        </div>
                        
                        <div class="modal-field">
                            <label for="uda-total-hours-${sectionId}">Ore totali: <span class="hours-display" id="total-display-${sectionId}">${initialTotalHours}</span></label>
                            <div class="slider-container">
                                <input type="range" id="uda-total-slider-${sectionId}" class="modal-slider" min="${minimumHours}" max="${remaining}" value="${initialTotalHours}" step="1">
                                <input type="number" id="uda-total-hours-${sectionId}" class="modal-input slider-input" min="${minimumHours}" max="${section.totalHours}" value="${initialTotalHours}" required>
                            </div>
                        </div>
                        
                        <div class="modal-field">
                            <label for="uda-distance-hours-${sectionId}">Ore a distanza: <span class="hours-display" id="distance-display-${sectionId}">0</span></label>
                            <div class="slider-container">
                                <input type="range" id="uda-distance-slider-${sectionId}" class="modal-slider" min="0" max="${Math.min(remaining, maxDistanceAvailable)}" value="0" step="1">
                                <input type="number" id="uda-distance-hours-${sectionId}" class="modal-input slider-input" min="0" max="${maxDistanceAvailable}" value="0" required>
                            </div>
                        </div>
                        
                        <div class="modal-allocation-preview">
                            <div class="allocation-bar-container">
                                <div class="allocation-bar" id="modal-allocation-bar-${sectionId}">
                                    <div class="allocation-distance" id="modal-distance-bar-${sectionId}" style="width: 0%"></div>
                                </div>
                                <div class="allocation-labels">
                                    <span class="distance-label" id="modal-distance-label-${sectionId}">0h distanza</span>
                                    <span class="presence-label" id="modal-presence-label-${sectionId}">${initialTotalHours}h presenza</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="subtopic-modal-footer">
                    <button type="button" class="modal-button modal-cancel">Annulla</button>
                    <button type="button" class="modal-button modal-save">Salva UDA</button>
                </div>
            </div>
        `;

        // Aggiungi al DOM
        document.body.appendChild(modal);

        // Riferimenti agli elementi
        const nameInput = modal.querySelector(`#uda-name-${sectionId}`);
        const descInput = modal.querySelector(`#uda-description-${sectionId}`);
        const totalHoursInput = modal.querySelector(`#uda-total-hours-${sectionId}`);
        const distanceHoursInput = modal.querySelector(`#uda-distance-hours-${sectionId}`);
        const totalSlider = modal.querySelector(`#uda-total-slider-${sectionId}`);
        const distanceSlider = modal.querySelector(`#uda-distance-slider-${sectionId}`);
        const totalDisplay = modal.querySelector(`#total-display-${sectionId}`);
        const distanceDisplay = modal.querySelector(`#distance-display-${sectionId}`);
        const errorContainer = modal.querySelector(`#error-container-${sectionId}`);
        const errorMessage = modal.querySelector(`#error-message-${sectionId}`);
        const cancelButton = modal.querySelector('.modal-cancel');
        const saveButton = modal.querySelector('.modal-save');
        const closeButton = modal.querySelector('.modal-close-button');

        // Elementi per la barra di allocazione
        const distanceBar = modal.querySelector(`#modal-distance-bar-${sectionId}`);
        const distanceLabel = modal.querySelector(`#modal-distance-label-${sectionId}`);
        const presenceLabel = modal.querySelector(`#modal-presence-label-${sectionId}`);

        // Funzione per mostrare errori
        const showError = (message) => {
            errorMessage.textContent = message;
            errorContainer.style.display = 'block';
            errorContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        };

        // Funzione per nascondere errori
        const hideError = () => {
            errorContainer.style.display = 'none';
        };

        // Funzione per sincronizzare slider e input
        const syncTotalHours = () => {
            let value = parseInt(totalHoursInput.value, 10) || 0;

            if (value < minimumHours) {
                value = minimumHours;
                totalHoursInput.value = value;
            }

            // Limita lo slider al valore massimo disponibile (per la UI)
            const sliderMax = remaining;
            if (value <= sliderMax) {
                totalSlider.value = value;
            } else {
                value = sliderMax;
                totalHoursInput.value = value;
                totalSlider.value = sliderMax;
            }

            totalDisplay.textContent = value;

            // Il max delle ore a distanza è il minimo tra le ore totali e il limite della sezione
            const maxDistanceForThisUDA = Math.min(value, maxDistanceAvailable);
            distanceSlider.max = maxDistanceForThisUDA;
            
            // Se le ore a distanza superano il nuovo limite, riduci
            if (parseInt(distanceHoursInput.value) > maxDistanceForThisUDA) {
                distanceHoursInput.value = maxDistanceForThisUDA;
                distanceSlider.value = maxDistanceForThisUDA;
                distanceDisplay.textContent = maxDistanceForThisUDA;
            }
            
            updateAllocationBar();
        };

        const syncDistanceHours = () => {
            const value = parseInt(distanceHoursInput.value) || 0;
            distanceSlider.value = value;
            distanceDisplay.textContent = value;
            updateAllocationBar();
        };

        // Funzione per aggiornare la barra di allocazione
        const updateAllocationBar = () => {
            const totalHours = parseInt(totalHoursInput.value, 10) || 0;
            const distanceHours = parseInt(distanceHoursInput.value) || 0;
            const presenceHours = totalHours - distanceHours;

            if (totalHours > 0) {
                const distancePercentage = (distanceHours / totalHours) * 100;
                distanceBar.style.width = `${distancePercentage}%`;
                distanceLabel.textContent = `${distanceHours}h distanza`;
                presenceLabel.textContent = `${presenceHours}h presenza`;
            } else {
                distanceBar.style.width = '0%';
                distanceLabel.textContent = '0h distanza';
                presenceLabel.textContent = '0h presenza';
            }
        };

        // Event listeners per slider e input
        totalSlider.addEventListener('input', () => {
            totalHoursInput.value = totalSlider.value;
            syncTotalHours();
        });

        totalHoursInput.addEventListener('input', () => {
            syncTotalHours();
        });

        distanceSlider.addEventListener('input', () => {
            distanceHoursInput.value = distanceSlider.value;
            syncDistanceHours();
        });

        distanceHoursInput.addEventListener('input', () => {
            syncDistanceHours();
        });

        // Nascondi errori quando l'utente modifica i campi
        [nameInput, descInput, totalHoursInput, distanceHoursInput].forEach(input => {
            input.addEventListener('input', hideError);
        });

        // Funzione per chiudere il modal
        const closeModal = () => {
            document.body.removeChild(modal);
        };

        // Event listeners
        closeButton.addEventListener('click', closeModal);
        cancelButton.addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeModal();
        });

        // Salvataggio UDA
        saveButton.addEventListener('click', () => {
            const name = nameInput.value.trim();
            const description = descInput.value.trim();
            const totalHours = parseInt(totalHoursInput.value);
            const distanceHours = parseInt(distanceHoursInput.value) || 0;

            // Reset stili errore
            [nameInput, descInput, totalHoursInput, distanceHoursInput].forEach(input => {
                input.style.borderColor = '';
            });
            hideError();

            // Validazione con messaggi di errore dettagliati
            if (!name) {
                showError('⚠️ Inserisci il nome dell\'UDA');
                nameInput.focus();
                nameInput.style.borderColor = '#ef4444';
                return;
            }

            if (name.length < 3) {
                showError('⚠️ Il nome dell\'UDA deve essere di almeno 3 caratteri');
                nameInput.focus();
                nameInput.style.borderColor = '#ef4444';
                return;
            }

            if (!description) {
                showError('⚠️ Inserisci una descrizione per l\'UDA');
                descInput.focus();
                descInput.style.borderColor = '#ef4444';
                return;
            }

            if (description.length < 10) {
                showError('⚠️ La descrizione deve essere di almeno 10 caratteri');
                descInput.focus();
                descInput.style.borderColor = '#ef4444';
                return;
            }

            if (totalHours < minimumHours) {
                showError(`⚠️ Le ore totali devono essere almeno ${minimumHours}`);
                totalHoursInput.focus();
                totalHoursInput.style.borderColor = '#ef4444';
                return;
            }

            if (totalHours > remaining) {
                showError(`⚠️ Le ore totali (${totalHours}) superano quelle disponibili (${remaining})`);
                totalHoursInput.focus();
                totalHoursInput.style.borderColor = '#ef4444';
                return;
            }

            if (distanceHours > totalHours) {
                showError(`⚠️ Le ore a distanza (${distanceHours}) non possono superare le ore totali (${totalHours})`);
                distanceHoursInput.focus();
                distanceHoursInput.style.borderColor = '#ef4444';
                return;
            }

            if (distanceHours > maxDistanceAvailable) {
                showError(`⚠️ Le ore a distanza (${distanceHours}) superano il limite della materia (${maxDistanceAvailable}/${sectionDistanceCap})`);
                distanceHoursInput.focus();
                distanceHoursInput.style.borderColor = '#ef4444';
                return;
            }

            // Se tutto è valido, salva
            this.addUDA(sectionId, name, description, totalHours, distanceHours);
            closeModal();
        });

        // Inizializza la barra
        updateAllocationBar();

        // Focus sul primo input
        nameInput.focus();

        // Gestione tasto Escape
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }

    addUDA(sectionId, name, description, totalHours, distanceHours) {
        const context = this.findSection(sectionId);
        if (!context) return;

        const { section } = context;
        
        // Genera un ID univoco per l'UDA
        const udaId = `${sectionId}-uda-${section.subtopics.length + 1}`;
        
        // Crea la nuova UDA
        const minimumHours = this.minimumHoursPerSubtopic;
        const sanitizedTotal = Math.max(totalHours, minimumHours);

        const newUDA = {
            id: udaId,
            code: '',
            label: name,
            description: description,
            hours: sanitizedTotal,
            distanceHours: Math.min(distanceHours, sanitizedTotal)
        };

        // Aggiungi alla sezione
        section.subtopics.push(newUDA);

        // Per il SecondoLivello, ricarica completamente la visualizzazione
        if (this.state.selectedLevel === 'SecondoLivello') {
            this.renderDetails();
        } else {
            this.refreshSection(sectionId);
        }
        
        this.renderSummary();

        // Verifica se si supera il limite e mostra messaggio appropriato
        const remaining = this.sectionRemaining(section);
        if (remaining < 0) {
            this.showToast(`UDA "${name}" aggiunta con ${totalHours} ore (${distanceHours} a distanza). ⚠️ ATTENZIONE: Il totale supera il limite della materia di ${Math.abs(remaining)} ore.`, 'warning');
        } else {
            this.showToast(`UDA "${name}" aggiunta con ${totalHours} ore (${distanceHours} a distanza).`);
        }
    }

    showEditUDAForm(sectionId, subtopicId, buttonElement) {
        const context = this.findSection(sectionId);
        if (!context) return;

        const { section } = context;
        const subtopic = section.subtopics.find(s => s.id === subtopicId);
        if (!subtopic) return;

        const minimumHours = this.minimumHoursPerSubtopic;
        if (section.totalHours > 0 && subtopic.hours < minimumHours) {
            subtopic.hours = minimumHours;
        }

        const remaining = this.sectionRemaining(section);
        const maxAssignable = Math.min(section.totalHours, remaining + subtopic.hours);
        const sectionDistanceCap = this.sectionDistanceCap(section);
        const sectionDistanceAllocated = this.sectionDistanceAllocated(section);
        // Calcola il limite disponibile escludendo le ore di questa UDA dalle allocate
        const otherDistanceAllocated = sectionDistanceAllocated - (subtopic.distanceHours || 0);
        const maxDistanceAvailable = Math.max(0, sectionDistanceCap - otherDistanceAllocated);

        // Crea il modal popup (simile a showUDAForm ma con i valori dell'UDA esistente)
        const modal = document.createElement('div');
        modal.className = 'subtopic-modal-overlay';
        modal.innerHTML = `
            <div class="subtopic-modal">
                <div class="subtopic-modal-header">
                    <h3>Modifica UDA</h3>
                    <button type="button" class="modal-close-button" aria-label="Chiudi modal">×</button>
                </div>
                <div class="subtopic-modal-body">
                    <p class="modal-section-info">Materia: <strong>${section.title}</strong></p>
                    <p class="modal-hours-info">Ore disponibili: <strong>${maxAssignable}</strong> ${maxAssignable <= minimumHours ? '<span style="color: #d73502;">(Limite raggiunto - riduci altre voci per liberare ore)</span>' : ''}</p>
                    <p class="modal-distance-info">Limite ore a distanza: <strong>${maxDistanceAvailable}/${sectionDistanceCap}</strong> (20% del totale materia)</p>
                    
                    <div class="error-container" id="error-container-edit-${subtopicId}" style="display: none;">
                        <div class="error-message" id="error-message-edit-${subtopicId}"></div>
                    </div>
                    
                    <div class="modal-form">
                        <div class="modal-field">
                            <label for="uda-name-edit-${subtopicId}">Nome UDA:</label>
                            <input type="text" id="uda-name-edit-${subtopicId}" class="modal-input" value="${subtopic.label}" required>
                        </div>
                        
                        <div class="modal-field">
                            <label for="uda-description-edit-${subtopicId}">Descrizione:</label>
                            <textarea id="uda-description-edit-${subtopicId}" class="modal-input modal-textarea" rows="4" required>${subtopic.description || ''}</textarea>
                        </div>
                        
                        <div class="modal-field">
                            <label for="uda-total-hours-edit-${subtopicId}">Ore totali: <span class="hours-display" id="total-display-edit-${subtopicId}">${subtopic.hours}</span></label>
                            <div class="slider-container">
                                <input type="range" id="uda-total-slider-edit-${subtopicId}" class="modal-slider" min="${minimumHours}" max="${maxAssignable}" value="${subtopic.hours}" step="1">
                                <input type="number" id="uda-total-hours-edit-${subtopicId}" class="modal-input slider-input" min="${minimumHours}" max="${maxAssignable}" value="${subtopic.hours}" required>
                            </div>
                        </div>
                        
                        <div class="modal-field">
                            <label for="uda-distance-hours-edit-${subtopicId}">Ore a distanza: <span class="hours-display" id="distance-display-edit-${subtopicId}">${subtopic.distanceHours || 0}</span></label>
                            <div class="slider-container">
                                <input type="range" id="uda-distance-slider-edit-${subtopicId}" class="modal-slider" min="0" max="${Math.min(subtopic.hours, Math.max(maxDistanceAvailable, subtopic.distanceHours || 0))}" value="${subtopic.distanceHours || 0}" step="1">
                                <input type="number" id="uda-distance-hours-edit-${subtopicId}" class="modal-input slider-input" min="0" max="${maxDistanceAvailable}" value="${subtopic.distanceHours || 0}" required>
                            </div>
                        </div>
                        
                        <div class="modal-allocation-preview">
                            <div class="allocation-bar-container">
                                <div class="allocation-bar" id="modal-allocation-bar-edit-${subtopicId}">
                                    <div class="allocation-distance" id="modal-distance-bar-edit-${subtopicId}" style="width: ${subtopic.hours > 0 ? ((subtopic.distanceHours || 0) / subtopic.hours * 100) : 0}%"></div>
                                </div>
                                <div class="allocation-labels">
                                    <span class="distance-label" id="modal-distance-label-edit-${subtopicId}">${subtopic.distanceHours || 0}h distanza</span>
                                    <span class="presence-label" id="modal-presence-label-edit-${subtopicId}">${subtopic.hours - (subtopic.distanceHours || 0)}h presenza</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="subtopic-modal-footer">
                    <button type="button" class="modal-button modal-cancel">Annulla</button>
                    <button type="button" class="modal-button modal-save">Salva Modifiche</button>
                </div>
            </div>
        `;

        // Aggiungi al DOM
        document.body.appendChild(modal);

        // Setup degli event listeners (simile a showUDAForm)
        this.setupEditUDAFormListeners(modal, sectionId, subtopicId, maxDistanceAvailable);
    }

    confirmDeleteUDA(sectionId, subtopicId) {
        const context = this.findSection(sectionId);
        if (!context) return;

        const { section } = context;
        const subtopic = section.subtopics.find(s => s.id === subtopicId);
        if (!subtopic) return;

        if (confirm(`Sei sicuro di voler eliminare l'UDA "${subtopic.label}"?`)) {
            this.deleteUDA(sectionId, subtopicId);
        }
    }

    deleteUDA(sectionId, subtopicId) {
        const context = this.findSection(sectionId);
        if (!context) return;

        const { section } = context;
        const subtopicIndex = section.subtopics.findIndex(s => s.id === subtopicId);
        if (subtopicIndex === -1) return;

        const deletedUDA = section.subtopics[subtopicIndex];
        section.subtopics.splice(subtopicIndex, 1);

        // Ricarica la visualizzazione
        if (this.state.selectedLevel === 'SecondoLivello') {
            this.renderDetails();
        } else {
            this.refreshSection(sectionId);
        }
        
        this.renderSummary();

        this.showToast(`UDA "${deletedUDA.label}" eliminata.`, 'success');
    }

    setupEditUDAFormListeners(modal, sectionId, subtopicId, maxDistanceAvailable) {
        // Riferimenti agli elementi (simile a showUDAForm)
        const nameInput = modal.querySelector(`#uda-name-edit-${subtopicId}`);
        const descInput = modal.querySelector(`#uda-description-edit-${subtopicId}`);
    const totalHoursInput = modal.querySelector(`#uda-total-hours-edit-${subtopicId}`);
        const distanceHoursInput = modal.querySelector(`#uda-distance-hours-edit-${subtopicId}`);
        const totalSlider = modal.querySelector(`#uda-total-slider-edit-${subtopicId}`);
        const distanceSlider = modal.querySelector(`#uda-distance-slider-edit-${subtopicId}`);
        const totalDisplay = modal.querySelector(`#total-display-edit-${subtopicId}`);
        const distanceDisplay = modal.querySelector(`#distance-display-edit-${subtopicId}`);
        const errorContainer = modal.querySelector(`#error-container-edit-${subtopicId}`);
        const errorMessage = modal.querySelector(`#error-message-edit-${subtopicId}`);
        const cancelButton = modal.querySelector('.modal-cancel');
        const saveButton = modal.querySelector('.modal-save');
        const closeButton = modal.querySelector('.modal-close-button');

        // Elementi per la barra di allocazione
        const distanceBar = modal.querySelector(`#modal-distance-bar-edit-${subtopicId}`);
        const distanceLabel = modal.querySelector(`#modal-distance-label-edit-${subtopicId}`);
        const presenceLabel = modal.querySelector(`#modal-presence-label-edit-${subtopicId}`);

        const minimumHours = this.minimumHoursPerSubtopic;

        // Funzioni di gestione (simili a showUDAForm)
        const showError = (message) => {
            errorMessage.textContent = message;
            errorContainer.style.display = 'block';
            errorContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        };

        const hideError = () => {
            errorContainer.style.display = 'none';
        };

        const syncTotalHours = () => {
            let value = parseInt(totalHoursInput.value, 10) || 0;
            const sliderMax = Number(totalSlider.max);

            if (value < minimumHours) {
                value = minimumHours;
            }

            if (value > sliderMax) {
                value = sliderMax;
            }

            totalHoursInput.value = value;
            totalSlider.value = value;
            totalDisplay.textContent = value;

            const maxDistanceForThisUDA = Math.min(value, maxDistanceAvailable);
            distanceSlider.max = maxDistanceForThisUDA;

            let distanceValue = parseInt(distanceHoursInput.value, 10) || 0;
            if (distanceValue > maxDistanceForThisUDA) {
                distanceValue = maxDistanceForThisUDA;
            }
            if (distanceValue < 0) {
                distanceValue = 0;
            }

            distanceHoursInput.value = distanceValue;
            distanceSlider.value = distanceValue;
            distanceDisplay.textContent = distanceValue;

            updateAllocationBar();
        };

        const syncDistanceHours = () => {
            let value = parseInt(distanceHoursInput.value, 10) || 0;
            const sliderMax = Number(distanceSlider.max);

            if (value < 0) {
                value = 0;
            }

            if (value > sliderMax) {
                value = sliderMax;
            }

            distanceHoursInput.value = value;
            distanceSlider.value = value;
            distanceDisplay.textContent = value;
            updateAllocationBar();
        };

        const updateAllocationBar = () => {
            const totalHours = parseInt(totalHoursInput.value, 10) || 0;
            const distanceHours = parseInt(distanceHoursInput.value, 10) || 0;
            const presenceHours = totalHours - distanceHours;

            if (totalHours > 0) {
                const distancePercentage = (distanceHours / totalHours) * 100;
                distanceBar.style.width = `${distancePercentage}%`;
                distanceLabel.textContent = `${distanceHours}h distanza`;
                presenceLabel.textContent = `${presenceHours}h presenza`;
            } else {
                distanceBar.style.width = '0%';
                distanceLabel.textContent = '0h distanza';
                presenceLabel.textContent = '0h presenza';
            }
        };

        // Event listeners
        totalSlider.addEventListener('input', () => {
            totalHoursInput.value = totalSlider.value;
            syncTotalHours();
        });

        totalHoursInput.addEventListener('input', syncTotalHours);
        distanceSlider.addEventListener('input', () => {
            distanceHoursInput.value = distanceSlider.value;
            syncDistanceHours();
        });
        distanceHoursInput.addEventListener('input', syncDistanceHours);

        [nameInput, descInput, totalHoursInput, distanceHoursInput].forEach(input => {
            input.addEventListener('input', hideError);
        });

        // Chiusura modal
        const closeModal = () => modal.remove();
        cancelButton.addEventListener('click', closeModal);
        closeButton.addEventListener('click', closeModal);

        // Salvataggio
        saveButton.addEventListener('click', () => {
            const name = nameInput.value.trim();
            const description = descInput.value.trim();
            const totalHours = parseInt(totalHoursInput.value, 10) || 0;
            const distanceHours = parseInt(distanceHoursInput.value, 10) || 0;

            // Validazione
            if (!name) {
                showError('Il nome dell\'UDA è obbligatorio.');
                nameInput.focus();
                return;
            }

            if (!description) {
                showError('La descrizione dell\'UDA è obbligatoria.');
                descInput.focus();
                return;
            }

            if (totalHours < minimumHours) {
                showError(`Le ore totali devono essere almeno ${minimumHours}.`);
                totalHoursInput.focus();
                return;
            }

            if (distanceHours > totalHours) {
                showError('Le ore a distanza non possono superare le ore totali.');
                distanceHoursInput.focus();
                return;
            }

            if (distanceHours > maxDistanceAvailable) {
                showError('Le ore a distanza superano il limite disponibile per questa materia.');
                distanceHoursInput.focus();
                return;
            }

            // Salva le modifiche
            this.updateUDA(sectionId, subtopicId, name, description, totalHours, distanceHours);
            closeModal();
        });

        // Sincronizza stato iniziale
        syncTotalHours();

        // Focus iniziale
        nameInput.focus();
        nameInput.select();
    }

    updateUDA(sectionId, subtopicId, name, description, totalHours, distanceHours) {
        const context = this.findSection(sectionId);
        if (!context) return;

        const { section } = context;
        const subtopic = section.subtopics.find(s => s.id === subtopicId);
        if (!subtopic) return;

        const minimumHours = this.minimumHoursPerSubtopic;
        const sanitizedTotal = Math.max(totalHours, minimumHours);
        const sanitizedDistance = Math.min(distanceHours, sanitizedTotal);

        // Aggiorna l'UDA
        subtopic.label = name;
        subtopic.description = description;
        subtopic.hours = sanitizedTotal;
        subtopic.distanceHours = sanitizedDistance;

        // Ricarica la visualizzazione
        if (this.state.selectedLevel === 'SecondoLivello') {
            this.renderDetails();
        } else {
            this.refreshSection(sectionId);
        }
        
        this.renderSummary();

        // Verifica se si supera il limite e mostra messaggio appropriato
        const remaining = this.sectionRemaining(section);
        if (remaining < 0) {
            this.showToast(`UDA "${name}" modificata. ⚠️ ATTENZIONE: Il totale supera il limite della materia di ${Math.abs(remaining)} ore.`, 'warning');
        } else {
            this.showToast(`UDA "${name}" modificata con successo.`, 'success');
        }
    }

    handleMenuItemClick = (event) => {
        const menuItemId = event.target.dataset.menuItem;
        const levelId = event.target.dataset.levelId;
        
        if (!menuItemId || !levelId) {
            return;
        }

        // Trova il livello e l'item del menu
        const levelKey = this.state.selectedLevel;
        const levelData = this.data[levelKey];
        if (!levelData || !levelData.levels) {
            return;
        }

        const level = levelData.levels.find(l => l.id === levelId);
        if (!level || !level.menuItems) {
            return;
        }

        const menuItem = level.menuItems.find(item => item.id === menuItemId);
        if (!menuItem) {
            return;
        }

        // Mostra il contenuto del menu item
        const contentContainer = this.elements.detailsPanel.querySelector(`#menu-content-${levelId}`);
        if (!contentContainer) {
            return;
        }

        // Nascondi tutti gli altri contenuti del menu
        const allMenuContents = this.elements.detailsPanel.querySelectorAll('.menu-content');
        allMenuContents.forEach(content => {
            content.style.display = 'none';
        });

        // Rimuovi classe active da tutti i pulsanti del menu
        const allMenuButtons = this.elements.detailsPanel.querySelectorAll('.menu-item-button');
        allMenuButtons.forEach(btn => {
            btn.classList.remove('active');
        });

        // Aggiungi classe active al pulsante cliccato
        event.target.classList.add('active');

        // Mostra il contenuto selezionato
        contentContainer.style.display = 'block';
        contentContainer.innerHTML = this.renderMenuItemContent(menuItem);

        // Riattacca le interazioni per il nuovo contenuto
        this.attachInteractionsToMenuContent(contentContainer);
    };

    renderMenuItemContent(menuItem) {
        if (!menuItem.sections || menuItem.sections.length === 0) {
            return `
                <div class="empty-state">
                    <h3>${menuItem.name}</h3>
                    <p>Contenuti in fase di definizione per questa sezione.</p>
                </div>
            `;
        }

        return `
            <div class="menu-item-content">
                <h3 class="menu-item-title">${menuItem.name}</h3>
                <div class="section-grid">
                    ${menuItem.sections.map((section) => this.renderSection(section)).join('')}
                </div>
            </div>
        `;
    }

    attachInteractionsToMenuContent(container) {
        const sliders = container.querySelectorAll('.subtopic-slider');
        const inputs = container.querySelectorAll('.subtopic-input');
        const distanceSliders = container.querySelectorAll('.subtopic-distance-slider');
        const distanceInputs = container.querySelectorAll('.subtopic-distance-input');

        sliders.forEach((slider) => {
            slider.addEventListener('input', this.handleAllocationUpdate);
        });

        inputs.forEach((input) => {
            input.addEventListener('change', this.handleAllocationUpdate);
            input.addEventListener('input', (event) => {
                if (event.target.value === '') {
                    return;
                }
                this.handleAllocationUpdate(event);
            });
        });

        distanceSliders.forEach((slider) => {
            if (slider.disabled) {
                return;
            }
            slider.addEventListener('input', this.handleDistanceUpdate);
            slider.addEventListener('change', this.handleDistanceUpdate);
        });

        distanceInputs.forEach((input) => {
            if (input.disabled) {
                return;
            }
            input.addEventListener('change', this.handleDistanceUpdate);
            input.addEventListener('input', (event) => {
                if (event.target.value === '') {
                    return;
                }
                this.handleDistanceUpdate(event);
            });
        });
    }

    handleAllocationUpdate = (event) => {
        const { sectionId, subtopicId } = event.target.dataset;
        if (!sectionId || !subtopicId) {
            return;
        }

        const parsedValue = Number.parseInt(event.target.value, 10);
        const newValue = Number.isNaN(parsedValue) ? 0 : parsedValue;

        this.updateAllocation(sectionId, subtopicId, newValue);
    };

    handleDistanceUpdate = (event) => {
        const { sectionId, subtopicId } = event.target.dataset;
        if (!sectionId || !subtopicId) {
            return;
        }

        const parsedValue = Number.parseInt(event.target.value, 10);
        const newValue = Number.isNaN(parsedValue) ? 0 : parsedValue;

        this.updateDistanceAllocation(sectionId, subtopicId, newValue);
    };

    updateAllocation(sectionId, subtopicId, proposedValue) {
        const context = this.findSection(sectionId);
        if (!context) {
            return;
        }

        const { section } = context;
        const subtopic = section.subtopics.find((sub) => sub.id === subtopicId);

        if (!subtopic) {
            return;
        }

        const sanitized = Math.max(0, Math.round(proposedValue));
        const otherSum = section.subtopics.reduce((sum, sub) => sum + (sub.id === subtopicId ? 0 : sub.hours), 0);
        const maxAllowed = Math.max(0, section.totalHours - otherSum);
        const minimumHours = section.totalHours > 0 ? this.minimumHoursPerSubtopic : 0;

        if (section.totalHours > 0 && maxAllowed < minimumHours) {
            this.showToast(`Per questa voce servono almeno ${minimumHours} ora disponibili. Riduci le altre attività per liberare ore.`, 'warning');
            this.refreshSection(section.id);
            return;
        }

        let finalValue = sanitized;

        if (section.totalHours > 0) {
            if (finalValue < minimumHours) {
                finalValue = minimumHours;
                if (sanitized < minimumHours) {
                    this.showToast(`Ogni voce deve avere almeno ${minimumHours} ora.`);
                }
            }

            if (finalValue > maxAllowed) {
                finalValue = maxAllowed;
            }

            finalValue = Math.max(minimumHours, finalValue);
        } else {
            finalValue = Math.min(finalValue, maxAllowed);
        }

        if (sanitized > maxAllowed) {
            const remaining = Math.max(0, maxAllowed);
            const message = remaining === 0
                ? 'Tutte le ore per questa voce sono già distribuite.'
                : `Puoi assegnare al massimo ${remaining} ore a questa voce.`;
            this.showToast(message);
        }

        if (finalValue === subtopic.hours) {
            this.refreshSection(section.id);
            this.renderSummary();
            return;
        }

        subtopic.hours = finalValue;

        const sectionCap = this.sectionDistanceCap(section);
        const totalDistance = this.sectionDistanceAllocated(section);
        if (totalDistance > sectionCap) {
            const otherDistance = totalDistance - (subtopic.distanceHours || 0);
            const allowedForThis = Math.max(0, sectionCap - otherDistance);
            if (subtopic.distanceHours > allowedForThis) {
                subtopic.distanceHours = allowedForThis;
                this.showToast('Ore distanza ridotte per rispettare il 20% della sezione.');
            }
        }

        if ((subtopic.distanceHours || 0) > subtopic.hours) {
            subtopic.distanceHours = subtopic.hours;
        }

        this.refreshSection(section.id);
        this.renderSummary();
    }

    updateDistanceAllocation(sectionId, subtopicId, proposedValue) {
        const context = this.findSection(sectionId);
        if (!context) {
            return;
        }

        const { section } = context;
        const subtopic = section.subtopics.find((sub) => sub.id === subtopicId);

        if (!subtopic) {
            return;
        }

        const sanitized = Math.max(0, Math.round(proposedValue));
        const sectionCap = this.sectionDistanceCap(section);
        const otherDistance = section.subtopics.reduce((sum, s) => sum + (s.id === subtopic.id ? 0 : (s.distanceHours || 0)), 0);
        const remainingForSection = Math.max(0, sectionCap - otherDistance);
        
        // Il limite per questa voce è il minimo tra:
        // 1. Le ore totali della voce
        // 2. Le ore a distanza rimanenti per la sezione + quelle già assegnate a questa voce
        const maxAllowedForThis = Math.min(subtopic.hours, remainingForSection);
        const finalValue = Math.min(sanitized, maxAllowedForThis);

        if (sanitized > subtopic.hours) {
            this.showToast('Le ore a distanza non possono superare le ore totali della voce.');
        } else if (sanitized > maxAllowedForThis) {
            this.showToast(`Limite distanza di sezione raggiunto. Puoi assegnare al massimo ${maxAllowedForThis} ore a distanza a questa voce.`);
        }

        subtopic.distanceHours = finalValue;

        this.refreshSection(section.id);
        this.renderSummary();

        const sectionElement = this.elements.detailsPanel.querySelector(`[data-section-id="${section.id}"]`);
        if (!sectionElement) {
            return;
        }

        const subtopicElement = sectionElement.querySelector(`.subtopic[data-subtopic-id="${subtopic.id}"]`);
        if (!subtopicElement) {
            return;
        }

        const slider = subtopicElement.querySelector('.subtopic-distance-slider');
        if (slider) {
            const updatedSectionCap = this.sectionDistanceCap(section);
            const totalDistance = this.sectionDistanceAllocated(section);
            const otherAllocated = totalDistance - subtopic.distanceHours;
            const remainingForSection = Math.max(0, updatedSectionCap - otherAllocated);
            const maxAllowedForThis = Math.min(subtopic.hours, remainingForSection);
            slider.max = updatedSectionCap;
            slider.value = subtopic.distanceHours;
            const percent = updatedSectionCap > 0 ? Math.min(100, Math.round((subtopic.distanceHours / updatedSectionCap) * 100)) : 0;
            slider.style.background = this.buildDistanceSliderGradient(percent);
            slider.setAttribute('aria-valuemax', updatedSectionCap);
            slider.setAttribute('aria-valuenow', String(subtopic.distanceHours));

            const numberInput = subtopicElement.querySelector('.subtopic-distance-input');
            if (numberInput) {
                numberInput.max = updatedSectionCap;
                numberInput.disabled = updatedSectionCap === 0;
                numberInput.value = subtopic.distanceHours;
            }


        }

        const distanceValueLabel = subtopicElement.querySelector('.distance-value');
        if (distanceValueLabel) {
            distanceValueLabel.textContent = subtopic.distanceHours;
        }
    }

    refreshSection(sectionId) {
        const sectionElement = this.elements.detailsPanel.querySelector(`[data-section-id="${sectionId}"]`);
        const context = this.findSection(sectionId);

        if (!sectionElement || !context) {
            return;
        }

        const { section } = context;
        const allocated = this.sectionAllocated(section);
        const remaining = this.sectionRemaining(section);
        const completion = section.totalHours > 0 ? Math.min(100, Math.round((allocated / section.totalHours) * 100)) : 0;
        const distanceAllocated = this.sectionDistanceAllocated(section);
        const distanceCap = this.sectionDistanceCap(section);
        const distanceRemaining = Math.max(0, distanceCap - distanceAllocated);
        const distanceStatus = distanceCap === 0
            ? 'Nessuna distanza prevista.'
            : `Residuo distanza sezione: ${distanceRemaining} h`;

        const progressBar = sectionElement.querySelector('.progress__bar');
        if (progressBar) {
            progressBar.style.width = `${completion}%`;
        }

        const feedback = sectionElement.querySelector('.section-feedback');
        if (feedback) {
            feedback.classList.toggle('--warning', !(remaining === 0 && section.totalHours > 0));
            const counter = feedback.querySelector('.section-feedback__counter');
            const status = feedback.querySelector('.section-feedback__status');
            if (counter) {
                counter.innerHTML = `Assegnate <strong>${allocated}</strong> ore`;
            }
            if (status) {
                status.textContent = remaining === 0 && section.totalHours > 0
                    ? 'Distribuzione completata'
                    : `Ore da assegnare: ${remaining}`;
            }
        }

        sectionElement.classList.toggle('complete', remaining === 0 && section.totalHours > 0);

        const distanceSection = sectionElement.querySelector('.section-distance');
        if (distanceSection) {
            if (distanceAllocated > 0 || distanceCap > 0) {
                distanceSection.style.display = '';
                const distanceCounter = distanceSection.querySelector('.section-distance__counter');
                if (distanceCounter) {
                    distanceCounter.innerHTML = distanceCap > 0
                        ? `Distanza (somma voci): <strong>${distanceAllocated}</strong> / ${distanceCap}`
                        : `Distanza (somma voci): <strong>${distanceAllocated}</strong>`;
                }
                const distanceState = distanceSection.querySelector('.section-distance__status');
                if (distanceState) {
                    distanceState.textContent = distanceStatus;
                }
            } else {
                distanceSection.style.display = 'none';
            }
        }

        section.subtopics.forEach((subtopic) => {
            const subtopicElement = sectionElement.querySelector(`.subtopic[data-subtopic-id="${subtopic.id}"]`);
            if (!subtopicElement) {
                return;
            }

            const hoursLabel = subtopicElement.querySelector('.subtopic-hours');
            if (hoursLabel) {
                if (subtopic.hours > 0) {
                    hoursLabel.textContent = `${subtopic.hours} h totali`;
                    hoursLabel.style.display = '';
                } else {
                    hoursLabel.style.display = 'none';
                }
            }

            const distanceTag = subtopicElement.querySelector('.subtopic-distance-tag');
            if (distanceTag) {
                if ((subtopic.distanceHours || 0) > 0) {
                    distanceTag.textContent = `${subtopic.distanceHours} h distanza`;
                    distanceTag.style.display = '';
                } else {
                    distanceTag.style.display = 'none';
                }
            }

            const slider = subtopicElement.querySelector('.subtopic-slider');
            if (slider) {
                slider.value = subtopic.hours;
                
                // Calcola la percentuale considerando il range effettivo (da minimumHours a totalHours)
                let percent = 0;
                if (section.totalHours > 0) {
                    const minimumHours = this.minimumHoursPerSubtopic;
                    const effectiveValue = subtopic.hours - minimumHours;
                    const effectiveMax = section.totalHours - minimumHours;
                    percent = effectiveMax > 0 ? Math.round((effectiveValue / effectiveMax) * 100) : 0;
                }
                
                slider.style.background = this.buildSliderGradient(percent);
            }

            const input = subtopicElement.querySelector('.subtopic-input');
            if (input && document.activeElement !== input) {
                input.value = subtopic.hours;
            }

            const presenceHours = Math.max(0, subtopic.hours - (subtopic.distanceHours || 0));
            
            const presenceInput = subtopicElement.querySelector('.subtopic-presence-input');
            if (presenceInput) {
                presenceInput.value = presenceHours;
            }

            const distributionLabels = subtopicElement.querySelectorAll('.subtopic-distribution strong');
            if (distributionLabels[0]) {
                distributionLabels[0].textContent = presenceHours;
            }
            if (distributionLabels[1]) {
                distributionLabels[1].textContent = subtopic.distanceHours;
            }

            const distanceSlider = subtopicElement.querySelector('.subtopic-distance-slider');
            const distanceInput = subtopicElement.querySelector('.subtopic-distance-input');
            if (distanceSlider) {
                const updatedSectionCap = this.sectionDistanceCap(section);
                const totalDistance = this.sectionDistanceAllocated(section);
                const currentDistance = subtopic.distanceHours || 0;
                const otherDistance = totalDistance - currentDistance;
                const remainingForSection = Math.max(0, updatedSectionCap - otherDistance);
                const maxAllowedForThis = Math.min(subtopic.hours, remainingForSection);

                distanceSlider.max = updatedSectionCap;
                distanceSlider.disabled = updatedSectionCap === 0;
                if (document.activeElement !== distanceSlider) {
                    distanceSlider.value = subtopic.distanceHours;
                }
                const percent = updatedSectionCap > 0 ? Math.min(100, Math.round((subtopic.distanceHours / updatedSectionCap) * 100)) : 0;
                distanceSlider.style.background = this.buildDistanceSliderGradient(percent);
                distanceSlider.setAttribute('aria-valuemax', updatedSectionCap);
                distanceSlider.setAttribute('aria-valuenow', String(subtopic.distanceHours));

                const distanceValueLabel = subtopicElement.querySelector('.distance-value');
                if (distanceValueLabel) {
                    distanceValueLabel.textContent = subtopic.distanceHours;
                }


            }

            if (distanceInput) {
                const updatedSectionCap = this.sectionDistanceCap(section);
                distanceInput.max = updatedSectionCap;
                distanceInput.disabled = updatedSectionCap === 0;
                if (document.activeElement !== distanceInput) {
                    distanceInput.value = subtopic.distanceHours;
                }
            }
        });
    }

    buildSliderGradient(percent) {
        return `linear-gradient(90deg, rgba(99, 102, 241, 0.85) 0%, rgba(99, 102, 241, 0.85) ${percent}%, rgba(203, 213, 225, 0.5) ${percent}%, rgba(203, 213, 225, 0.5) 100%)`;
    }

    buildDistanceSliderGradient(percent) {
        return `linear-gradient(90deg, rgba(14,165,233,0.9) 0%, rgba(14,165,233,0.9) ${percent}%, rgba(148,163,184,0.35) ${percent}%, rgba(148,163,184,0.35) 100%)`;
    }

    findSection(sectionId) {
        const levelKey = this.state.selectedLevel;
        if (!levelKey) {
            return null;
        }

        const levelData = this.data[levelKey];
        if (!levelData) {
            return null;
        }

        // Gestione struttura normale (Alpha, Primo, Secondo)
        if (levelData.levels) {
            for (const level of levelData.levels) {
                const section = level.sections.find((item) => item.id === sectionId);
                if (section) {
                    return { level, section };
                }
            }
        }

        // Gestione struttura SecondoLivello (periods -> classes -> sections)
        if (levelData.periods) {
            for (const periodId of Object.keys(levelData.periods)) {
                const period = levelData.periods[periodId];
                if (period.classes) {
                    for (const classId of Object.keys(period.classes)) {
                        const classData = period.classes[classId];
                        if (classData.sections) {
                            const section = classData.sections.find((item) => item.id === sectionId);
                            if (section) {
                                return { 
                                    level: { 
                                        id: `${periodId}-${classId}`, 
                                        name: `${period.name} - Classe ${classData.name}`,
                                        sections: classData.sections 
                                    }, 
                                    section 
                                };
                            }
                        }
                    }
                }
            }
        }

        return null;
    }

    initializeMinimumHours() {
        const applyMinimumToSections = (sections = []) => {
            if (!Array.isArray(sections)) {
                return;
            }

            sections.forEach((section) => {
                if (!section || !Array.isArray(section.subtopics) || section.totalHours <= 0) {
                    return;
                }

                section.subtopics.forEach((subtopic) => {
                    if (!subtopic) {
                        return;
                    }

                    // Imposta 1 ora di default per tutte le competenze che hanno 0 ore
                    if (subtopic.hours === 0) {
                        subtopic.hours = this.minimumHoursPerSubtopic;
                    }

                    // Assicura che nessuna competenza abbia meno di 1 ora
                    if (subtopic.hours < this.minimumHoursPerSubtopic) {
                        subtopic.hours = this.minimumHoursPerSubtopic;
                    }

                    if ((subtopic.distanceHours || 0) > subtopic.hours) {
                        subtopic.distanceHours = subtopic.hours;
                    }
                });
            });
        };

        Object.values(this.data).forEach((levelData) => {
            if (!levelData) {
                return;
            }

            if (Array.isArray(levelData.levels)) {
                levelData.levels.forEach((level) => applyMinimumToSections(level.sections));
            }

            if (levelData.periods) {
                Object.values(levelData.periods).forEach((period) => {
                    if (!period) {
                        return;
                    }

                    applyMinimumToSections(period.sections);

                    if (period.classes) {
                        Object.values(period.classes).forEach((classData) => {
                            applyMinimumToSections(classData?.sections);
                        });
                    }
                });
            }
        });
    }

    sectionAllocated(section) {
        return section.subtopics.reduce((sum, sub) => sum + sub.hours, 0);
    }

    sectionRemaining(section) {
        return Math.max(0, section.totalHours - this.sectionAllocated(section));
    }

    sectionDistanceAllocated(section) {
        return section.subtopics.reduce((sum, sub) => sum + (sub.distanceHours || 0), 0);
    }

    sectionDistanceCap(section) {
        return Math.floor((section.totalHours || 0) * this.distanceCapRatio);
    }

    sectionDistanceRemaining(section) {
        return Math.max(0, this.sectionDistanceCap(section) - this.sectionDistanceAllocated(section));
    }

    computeLevelTotals(level) {
        // Per livelli con menu, restituisci totali vuoti
        if (level.isMenuLevel || !level.sections) {
            return { total: 0, assigned: 0, remaining: 0, completedSections: 0, totalSections: 0, distanceAssigned: 0, distanceCap: 0 };
        }

        return level.sections.reduce((acc, section) => {
            const allocated = this.sectionAllocated(section);
            const remaining = this.sectionRemaining(section);
            const distanceAllocated = this.sectionDistanceAllocated(section);
            const distanceCap = this.sectionDistanceCap(section);
            acc.total += section.totalHours;
            acc.assigned += allocated;
            acc.remaining += remaining;
            acc.distanceAssigned += distanceAllocated;
            acc.distanceCap += distanceCap;
            if (remaining === 0 && section.totalHours > 0) {
                acc.completedSections += 1;
            }
            acc.totalSections += 1;
            return acc;
        }, { total: 0, assigned: 0, remaining: 0, completedSections: 0, totalSections: 0, distanceAssigned: 0, distanceCap: 0 });
    }

    collectSections(levelData) {
        const sections = [];
        if (!levelData) {
            return sections;
        }

        if (Array.isArray(levelData.levels)) {
            levelData.levels.forEach((level) => {
                if (Array.isArray(level.sections)) {
                    sections.push(...level.sections);
                }
            });
        }

        if (levelData.periods) {
            Object.values(levelData.periods).forEach((period) => {
                if (!period) {
                    return;
                }

                if (Array.isArray(period.sections)) {
                    sections.push(...period.sections);
                }

                if (period.classes) {
                    Object.values(period.classes).forEach((classData) => {
                        if (Array.isArray(classData?.sections)) {
                            sections.push(...classData.sections);
                        }
                    });
                }
            });
        }

        return sections;
    }

    isSectionComplete(section) {
        if (!section) {
            return false;
        }

        const total = section.totalHours || 0;
        if (total === 0) {
            return true;
        }

        if (!Array.isArray(section.subtopics) || section.subtopics.length === 0) {
            return false;
        }

        if (this.sectionRemaining(section) > 0) {
            return false;
        }

        return section.subtopics.every((subtopic) => (subtopic?.hours || 0) >= this.minimumHoursPerSubtopic);
    }

    isPlanComplete(levelData) {
        const sections = this.collectSections(levelData);
        if (sections.length === 0) {
            return false;
        }

        return sections.every((section) => this.isSectionComplete(section));
    }

    updateExportAvailability() {
        const printButton = this.elements.printButton;
        if (!printButton) {
            return;
        }

        const levelKey = this.state.selectedLevel;
        if (!levelKey) {
            printButton.disabled = true;
            printButton.setAttribute('aria-disabled', 'true');
            printButton.title = 'Seleziona un percorso per esportare il PDF.';
            return;
        }

        const levelData = this.data[levelKey];
        if (!levelData) {
            printButton.disabled = true;
            printButton.setAttribute('aria-disabled', 'true');
            printButton.title = 'Dati mancanti per il percorso selezionato.';
            return;
        }

        const planComplete = this.isPlanComplete(levelData);
        printButton.disabled = !planComplete;
        printButton.setAttribute('aria-disabled', planComplete ? 'false' : 'true');

        if (!planComplete) {
            printButton.title = 'Completa la distribuzione delle ore e assegna almeno 1 ora a ogni voce prima di esportare.';
        } else {
            printButton.removeAttribute('title');
        }
    }

    renderSummary() {
        this.updateExportAvailability();

        const levelKey = this.state.selectedLevel;
        const { summaryPanel, summaryContent } = this.elements;

        if (!levelKey) {
            summaryPanel.classList.add('hidden');
            return;
        }

        const levelData = this.data[levelKey];
        if (!levelData || !levelData.levels || levelData.levels.length === 0) {
            summaryPanel.classList.add('hidden');
            return;
        }

        const totals = {
            total: 0,
            assigned: 0,
            remaining: 0,
            completedSections: 0,
            totalSections: 0,
            distanceAssigned: 0,
            distanceCap: 0
        };

        const breakdown = levelData.levels.map((level) => {
            const stats = this.computeLevelTotals(level);
            totals.total += stats.total;
            totals.assigned += stats.assigned;
            totals.remaining += stats.remaining;
            totals.completedSections += stats.completedSections;
            totals.totalSections += stats.totalSections;
            totals.distanceAssigned += stats.distanceAssigned;
            totals.distanceCap += stats.distanceCap;
            return { level, stats };
        });

        const presenceHours = Math.max(0, totals.assigned - totals.distanceAssigned);

        const cards = [
            { label: 'Ore disponibili', value: `${totals.total} h` },
            { label: 'Ore assegnate', value: `${totals.assigned} h` },
            { label: 'Ore rimanenti', value: `${totals.remaining} h` },
            {
                label: 'Ore a distanza',
                value: totals.distanceCap > 0
                    ? `${totals.distanceAssigned}/${totals.distanceCap} h`
                    : `${totals.distanceAssigned} h`
            },
            { label: 'Ore in presenza', value: `${presenceHours} h` },
            { label: 'Sezioni complete', value: `${totals.completedSections}/${totals.totalSections}` }
        ];

        const breakdownCards = breakdown.map(({ level, stats }) => ({
            label: level.name,
            value: `${stats.assigned}/${stats.total} h`,
            meta: stats.distanceCap > 0
                ? `Distanza ${stats.distanceAssigned}/${stats.distanceCap} h`
                : 'Distanza non prevista'
        }));

        summaryContent.innerHTML = `
            ${[...cards, ...breakdownCards].map((item) => `
                <div class="summary-item">
                    <span>${item.label}</span>
                    <strong>${item.value}</strong>
                    ${item.meta ? `<small>${item.meta}</small>` : ''}
                </div>
            `).join('')}
        `;

        summaryPanel.classList.remove('hidden');

        let completionFlag = summaryPanel.querySelector('.completion-flag');
        if (!completionFlag) {
            completionFlag = document.createElement('div');
            completionFlag.className = 'completion-flag';
            summaryPanel.appendChild(completionFlag);
        }

        if (totals.total > 0 && totals.remaining === 0) {
            completionFlag.textContent = 'Hai distribuito tutte le ore disponibili! Ottimo lavoro.';
            completionFlag.classList.add('show');
        } else {
            completionFlag.textContent = 'Distribuisci tutte le ore per completare il percorso.';
            completionFlag.classList.remove('show');
        }
    }

    showToast(message, type = 'info') {
        const { toast } = this.elements;
        if (!toast) {
            return;
        }

        // Rimuovi classi precedenti di tipo
        toast.classList.remove('toast-info', 'toast-warning', 'toast-error', 'toast-success');
        
        // Aggiungi la classe appropriata per il tipo
        toast.classList.add(`toast-${type}`);
        
        toast.textContent = message;
        toast.classList.add('show');
        toast.setAttribute('aria-hidden', 'false');

        if (this.state.toastTimer) {
            clearTimeout(this.state.toastTimer);
        }

        // Messaggi di warning rimangono più a lungo
        const duration = type === 'warning' ? 4000 : 2500;
        this.state.toastTimer = setTimeout(() => this.clearToast(), duration);
    }

    clearToast() {
        const { toast } = this.elements;
        if (!toast) {
            return;
        }

        toast.classList.remove('show');
        toast.setAttribute('aria-hidden', 'true');
    }

    scrollToDetails() {
        if (!this.elements.detailsPanel) {
            return;
        }

        if (window.matchMedia('(max-width: 900px)').matches) {
            this.elements.detailsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    exportToPdf() {
        const levelKey = this.state.selectedLevel;
        if (!levelKey) {
            this.showToast('Seleziona prima un percorso da esportare.');
            return;
        }

        const levelData = this.data[levelKey];
        if (!levelData) {
            this.showToast('Nessun dato disponibile per l\'esportazione.');
            return;
        }

        // Verifica se ci sono dati da esportare
        const hasData = levelData.levels || levelData.periods;
        if (!hasData) {
            this.showToast('Nessun dato disponibile per l\'esportazione.');
            return;
        }

        if (!this.isPlanComplete(levelData)) {
            this.showToast('Completa la distribuzione delle ore e assegna almeno 1 ora a ogni voce prima di generare il PDF.', 'warning');
            return;
        }

        const jsPdfNamespace = window.jspdf || window.jsPDF;
        const jsPDF = jsPdfNamespace ? jsPdfNamespace.jsPDF || jsPdfNamespace : null;
        if (!jsPDF) {
            this.showToast('Impossibile generare il PDF (jsPDF non disponibile).');
            return;
        }

        const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
        const marginX = 14;
        const marginY = 18;
        const lineHeight = 6;
        const pageHeight = doc.internal.pageSize.getHeight();
        const safeMarginBottom = 20;

        let currentY = marginY + lineHeight;

        const ensureSpace = (required = lineHeight) => {
            if (currentY + required >= pageHeight - safeMarginBottom) {
                doc.addPage();
                currentY = marginY;
            }
        };

        doc.setFont('helvetica', 'bold');
        doc.setFontSize(16);
        doc.text(levelData.name, marginX, marginY);

        if (levelData.description) {
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(11);
            const descLines = doc.splitTextToSize(levelData.description, 180);
            descLines.forEach((line) => {
                ensureSpace(lineHeight);
                doc.text(line, marginX, currentY);
                currentY += lineHeight;
            });
            currentY += lineHeight / 2;
        }

        // Gestione struttura normale (Alpha, Primo, Secondo)
        if (levelData.levels) {
            levelData.levels.forEach((level, levelIndex) => {
            if (levelIndex > 0) {
                doc.addPage();
                currentY = marginY;
            }

            doc.setFont('helvetica', 'bold');
            doc.setFontSize(14);
            doc.text(level.name, marginX, currentY);
            currentY += lineHeight;

            const totals = this.computeLevelTotals(level);
            const presence = Math.max(0, totals.assigned - totals.distanceAssigned);
            const totalsText = `Ore totali ${totals.total} • Assegnate ${totals.assigned} • Presenza ${presence} • Distanza ${totals.distanceAssigned}${totals.distanceCap > 0 ? '/' + totals.distanceCap : ''}`;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10.5);
            const totalsLines = doc.splitTextToSize(totalsText, 180);
            totalsLines.forEach((line) => {
                ensureSpace(lineHeight);
                doc.text(line, marginX, currentY);
                currentY += lineHeight;
            });
            currentY += lineHeight / 3;

            level.sections.forEach((section, sectionIndex) => {
                if (sectionIndex > 0) {
                    currentY += lineHeight / 2;
                }

                ensureSpace(lineHeight * 2);
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(12);
                doc.text(section.title, marginX, currentY);
                currentY += lineHeight;

                const allocated = this.sectionAllocated(section);
                const distanceAllocated = this.sectionDistanceAllocated(section);
                const presenceHours = Math.max(0, allocated - distanceAllocated);
                const sectionCap = this.sectionDistanceCap(section);
                const sectionSummary = `Totale ${section.totalHours}h • Assegnate ${allocated}h • Presenza ${presenceHours}h • Distanza ${distanceAllocated}${sectionCap > 0 ? '/' + sectionCap : ''}h`;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(10);
                const summaryLines = doc.splitTextToSize(sectionSummary, 180);
                summaryLines.forEach((line) => {
                    ensureSpace(lineHeight);
                    doc.text(line, marginX, currentY);
                    currentY += lineHeight;
                });
                currentY += lineHeight / 3;

                const body = section.subtopics.map((subtopic) => {
                    const presence = Math.max(0, subtopic.hours - (subtopic.distanceHours || 0));
                    return [
                        subtopic.code || '',
                        doc.splitTextToSize(subtopic.label, 90),
                        this.formatHourLabel(subtopic.hours),
                        this.formatHourLabel(presence),
                        this.formatHourLabel(subtopic.distanceHours || 0)
                    ];
                });

                const tableOptions = {
                    startY: currentY,
                    head: [['Cod.', 'Voce', 'Ore tot.', 'Presenza', 'Distanza']],
                    body,
                    styles: {
                        font: 'helvetica',
                        fontSize: 9,
                        cellPadding: 2.6,
                        lineColor: [230, 233, 239],
                        lineWidth: 0.2
                    },
                    headStyles: {
                        fillColor: [99, 102, 241],
                        textColor: 255,
                        fontStyle: 'bold',
                        halign: 'center'
                    },
                    columnStyles: {
                        0: { halign: 'center', cellWidth: 16 },
                        1: { cellWidth: 90 },
                        2: { halign: 'center', cellWidth: 18 },
                        3: { halign: 'center', cellWidth: 20 },
                        4: { halign: 'center', cellWidth: 24 }
                    },
                    alternateRowStyles: {
                        fillColor: [248, 250, 252]
                    },
                    margin: { left: marginX, right: marginX },
                    didDrawPage: (data) => {
                        currentY = data.cursor.y + lineHeight;
                    }
                };

                if (typeof doc.autoTable === 'function') {
                    doc.autoTable(tableOptions);
                    currentY = doc.lastAutoTable ? doc.lastAutoTable.finalY + lineHeight : currentY + body.length * lineHeight;
                } else {
                    body.forEach((row) => {
                        ensureSpace(lineHeight * 2);
                        const [code, labelLines, total, presenceValue, distanceValue] = row;
                        const flattenedLabel = Array.isArray(labelLines) ? labelLines : [labelLines];
                        doc.setFont('helvetica', 'bold');
                        doc.text(code, marginX, currentY);
                        doc.setFont('helvetica', 'normal');
                        flattenedLabel.forEach((line) => {
                            ensureSpace(lineHeight);
                            doc.text(line, marginX + 12, currentY);
                            currentY += lineHeight;
                        });
                        const metrics = `Tot ${total} • Pres ${presenceValue} • Dist ${distanceValue}`;
                        ensureSpace(lineHeight);
                        doc.text(metrics, marginX + 12, currentY);
                        currentY += lineHeight;
                    });
                    currentY += lineHeight;
                }
            });
            });
        }

        // Gestione SecondoLivello (periods -> classes -> sections)
        if (levelData.periods) {
            let periodIndex = 0;
            Object.values(levelData.periods).forEach((period) => {
                if (periodIndex > 0) {
                    doc.addPage();
                    currentY = marginY;
                }

                doc.setFont('helvetica', 'bold');
                doc.setFontSize(14);
                doc.text(period.name, marginX, currentY);
                currentY += lineHeight * 2;

                if (period.classes) {
                    Object.values(period.classes).forEach((classData) => {
                        if (classData.sections && classData.sections.length > 0) {
                            ensureSpace(lineHeight * 3);
                            doc.setFont('helvetica', 'bold');
                            doc.setFontSize(13);
                            doc.text(`Classe ${classData.name}`, marginX + 6, currentY);
                            currentY += lineHeight;

                            // Calcola i totali per la classe
                            const classTotals = this.computeClassTotals(classData.sections);
                            const classPresence = Math.max(0, classTotals.assigned - classTotals.distanceAssigned);
                            const classSummaryText = `Ore totali ${classTotals.total} • Assegnate ${classTotals.assigned} • Presenza ${classPresence} • Distanza ${classTotals.distanceAssigned}/${classTotals.distanceCap}`;
                            
                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(10.5);
                            const classSummaryLines = doc.splitTextToSize(classSummaryText, 180);
                            classSummaryLines.forEach((line) => {
                                ensureSpace(lineHeight);
                                doc.text(line, marginX + 6, currentY);
                                currentY += lineHeight;
                            });
                            currentY += lineHeight / 3;

                            currentY = this.renderPdfSections(doc, classData.sections, marginX, currentY, lineHeight, ensureSpace);
                        }
                    });
                }
                periodIndex++;
            });
        }

        const filenameSafe = levelData.name.replace(/\s+/g, '_').replace(/[^A-Za-z0-9_\-]/g, '');
        doc.save(`Piano_${filenameSafe || 'curriculum'}.pdf`);
        this.showToast('PDF generato con successo.');
    }

    computeClassTotals(sections) {
        const totals = {
            total: 0,
            assigned: 0,
            remaining: 0,
            completedSections: 0,
            totalSections: sections.length,
            distanceAssigned: 0,
            distanceCap: 0
        };

        sections.forEach((section) => {
            const allocated = this.sectionAllocated(section);
            const distanceAllocated = this.sectionDistanceAllocated(section);
            const distanceCap = this.sectionDistanceCap(section);

            totals.total += section.totalHours || 0;
            totals.assigned += allocated;
            totals.distanceAssigned += distanceAllocated;
            totals.distanceCap += distanceCap;

            if (allocated >= section.totalHours) {
                totals.completedSections++;
            }
        });

        totals.remaining = Math.max(0, totals.total - totals.assigned);
        return totals;
    }

    renderPdfSections(doc, sections, marginX, startY, lineHeight, ensureSpace) {
        let currentY = startY;

        sections.forEach((section, sectionIndex) => {
            if (sectionIndex > 0) {
                currentY += lineHeight / 2;
            }

            ensureSpace(lineHeight * 2);
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(12);
            doc.text(`${section.title}`, marginX + 6, currentY);
            currentY += lineHeight;

            const allocated = this.sectionAllocated(section);
            const remaining = this.sectionRemaining(section);
            const distanceAllocated = this.sectionDistanceAllocated(section);
            const distanceCap = this.sectionDistanceCap(section);
            const presence = Math.max(0, allocated - distanceAllocated);
            const sectionSummary = `${allocated}/${section.totalHours} ore • Presenza ${presence} • Distanza ${distanceAllocated}${distanceCap > 0 ? '/' + distanceCap : ''} • Rimanenti ${remaining}`;

            doc.setFont('helvetica', 'italic');
            doc.setFontSize(10);
            doc.text(sectionSummary, marginX + 12, currentY);
            currentY += lineHeight;

            if (section.subtopics && section.subtopics.length > 0) {
                section.subtopics.forEach((subtopic) => {
                    if (subtopic.hours > 0) {
                        ensureSpace(lineHeight * 2);
                        const total = subtopic.hours;
                        const distanceValue = subtopic.distanceHours || 0;
                        const presenceValue = Math.max(0, total - distanceValue);
                        
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(9);
                        
                        // Nome UDA con descrizione se presente
                        let udaText = `${subtopic.code ? subtopic.code + '. ' : ''}${subtopic.label}`;
                        if (subtopic.description) {
                            udaText += ` - ${subtopic.description}`;
                        }
                        
                        // Dividi il testo se è troppo lungo
                        const udaLines = doc.splitTextToSize(udaText, 160);
                        udaLines.forEach((line, lineIndex) => {
                            if (lineIndex > 0) ensureSpace(lineHeight);
                            doc.text(line, marginX + 12, currentY);
                            currentY += lineHeight;
                        });

                        const metrics = `Tot ${total} • Pres ${presenceValue} • Dist ${distanceValue}`;
                        ensureSpace(lineHeight);
                        doc.text(metrics, marginX + 12, currentY);
                        currentY += lineHeight;
                    }
                });
                currentY += lineHeight;
            }
        });

        return currentY;
    }

    formatHourLabel(value) {
        const number = Number.isFinite(value) ? Number(value) : 0;
        return `${number} h`;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new CurriculumPlanner(curriculumModel);
});
